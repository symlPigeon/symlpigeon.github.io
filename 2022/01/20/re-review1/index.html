<!-- build time: Wed Sep 10 2025 16:38:05 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="google-site-verification" content="ZTJV7LmnjnAU0rDyvzCr7TRRA440DNEQPOSHt9OiYLE"><link rel="alternate" href="/rss.xml" title="symlpigeon's little gensokyo" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="symlpigeon's little gensokyo" type="application/atom+xml"><link rel="alternate" type="application/json" title="symlpigeon's little gensokyo" href="http://symlpigeon.github.io/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-4ZVORXXI.js"><link rel="modulepreload" href="/js/chunk-QTIRA53W.js"><link rel="modulepreload" href="/js/copy-tex-SCXHUQKS.js"><link rel="modulepreload" href="/js/post-XSNAZ6TV.js"><link rel="modulepreload" href="/js/quicklink-P2UCCMRY.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="/assets/index-bg.jpg" as="image" fetchpriority="high"><meta name="keywords" content="逆向工程,"><meta name="description" content="IA32体系结构的内存管理和分配，寄存器、数据存储类型。实际上是为了期末考试而恶补。"><link rel="canonical" href="http://symlpigeon.github.io/2022/01/20/re-review1/"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js"></script><style type="text/css">#categories-chart,#categories-radar,#posts-calendar,#posts-chart,#tags-chart{width:100%;height:300px;margin:.5rem auto;padding:.5rem;overflow-x:auto}</style><title>IA32内存、寄存器、数据</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">IA32内存、寄存器、数据</h1><div class="meta"><span class="item" title="创建时间：2022-01-20 15:39:55"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2022-01-20T15:39:55+08:00">2022-01-20</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>7.3k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Another Gensokyo</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="/assets/index-bg.jpg" loading="eager" decoding="async" fetchpriority="high" alt="symlpigeon's little gensokyo"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="item" rel="index" title="分类于二进制"><span itemprop="name">二进制<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于二进制基础"><span itemprop="name">二进制基础<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://symlpigeon.github.io/2022/01/20/re-review1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.png"><meta itemprop="name" content="神隐陌路/symlPigeon"><meta itemprop="description" content="神隐陌路的个人小站, 夢違え、幻の朝靄の世界の記憶を"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="symlpigeon's little gensokyo"></span><div class="body md" itemprop="articleBody"><p>等到开学就是期末考试了，这课从头到尾就根本没有听过，属于是要寄了。</p><p>得，开始恶补。</p><h1 id="x86和x64ia-32"><a class="anchor" href="#x86和x64ia-32">#</a> x86 和 x64，IA-32</h1><p>x86 指的是 Intel 在 8086/8088 之后的一系列后向兼容的指令集，也就是 IA-32 (Intel Architecture,32 bit)。</p><h2 id="工作模式"><a class="anchor" href="#工作模式">#</a> 工作模式</h2><p>IA-32 指令集支持三种基本的工作模式：<strong>保护模式 (protected mode)</strong>，<strong>实模式 (real-address mode)<strong> 和</strong>系统管理模式 (system management mode, SMM)</strong>。</p><p>IA-32 指令集属于 CISC (Complex Instruction Set Computer) 体系结构。</p><p><img loading="lazy" data-src="operation-modes.jpg" alt=""></p><p>这张图里面本来还包含 x64 的 IA-32e 模式的，因为这里涉及不到就删去了。</p><h3 id="保护模式"><a class="anchor" href="#保护模式">#</a> 保护模式</h3><p>保护模式是处理器的默认模式。</p><p>这种模式下能在受保护的多任务环境中直接执行 “实地址模式” 8086 软件（Among the capabilities of protected mode is the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment.）。</p><p>这个特性被称为<strong>虚拟 8086 模式 (virtual-8086 mode)</strong>。（也就是说 IA-32 处理器有两种方式来运行编译在 Intel 8086 处理器上面的程序，分别是虚拟 8086 模式和实模式），这个也被称作是<strong> quasi-opertaion mode</strong>，因为不算是单独的一类模式嘛。</p><p>在保护模式下，处理器支持虚拟内存、分页等功能，也能提供更好的多任务性能。目前主流的操作系统都是运行在这个模式下。</p><h3 id="实模式实地址模式"><a class="anchor" href="#实模式实地址模式">#</a> 实模式 / 实地址模式</h3><p>实模式实现了经过扩展的 8086 处理器的环境（This mode implements the programming environment of the Intel 8086 processor with extensions），能够切换至保护模式或系统管理模式。</p><p>实模式下只支持 16 位的寄存器，也就是只有 20 位的寻址空间（16+4）即 1MB 的内存空间。</p><p>在加电或者重置后，处理器处于实模式。</p><h3 id="系统管理模式"><a class="anchor" href="#系统管理模式">#</a> 系统管理模式</h3><p>系统管理模式能够给与操作系统或者程序一个透明的机制来实现基于平台的功能，如电源管理、系统安全等（This mode provides an operating system or executive with a transparent mechanism for implementing platform-specific functions such as power management and system security.）。</p><p>系统管理模式只能够通过<strong>系统管理中断 (System Management Interrupt, SMI)</strong> 或者触发外部 SMM 中断引脚 (SMI#) 进入。</p><h2 id="字节序"><a class="anchor" href="#字节序">#</a> 字节序</h2><blockquote><p><strong>字节序</strong>：多字节数据在计算机中存储或者传输的顺序。</p><p><strong>小端序 (little endian)</strong>：低位字节存储在内存中的低位地址。（Intel CPU）</p><p><strong>大端序 (big endian)</strong>：低位字节存储在内存中的高位地址。（一些 RISC 指令集 CPU）</p></blockquote><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span><span class="token number">0x61626364</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span><span class="token string">"big"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token string">b'abcd'</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span>byteorder<span class="token operator">=</span><span class="token string">"little"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token string">b'dcba'</span></pre></td></tr></table></figure><p>大概就是这种差别。</p><h2 id="权限级别"><a class="anchor" href="#权限级别">#</a> 权限级别</h2><p>为了提高操作系统的可靠性，IA-32 指令集架构有四个权限级别，分别是 ring 0~3，数字越低级别越高。</p><p><img loading="lazy" data-src="protection-ring.jpg" alt=""></p><p>最高的权限 Ring 0 一般是系统最关键模块的代码段（主要是操作系统的内核等），Ring 1 和 Ring 2 使用较少，一般是操作系统的一些服务和驱动等。用户态的程序一般运行在权限最低的 Ring 3。</p><p>较低权限段上面的代码模块要访问更高权限的代码段需要经过一个严格控制和保护的接口，也就是<strong> gate</strong>（不知道怎么翻译）。如果一个程序没有足够的权限而经过<strong> gate</strong> 访问更高权限的代码段，则会产生一个<strong>一般保护异常 (general-protection exception, #GP)</strong>。</p><h1 id="ia-32-内存"><a class="anchor" href="#ia-32-内存">#</a> IA-32 内存</h1><p><em>草，有一说一，Intel 的架构开发手册比老师的幻灯片讲得清楚多了……</em></p><p>插在处理器总线上面的内存<s>其实叫做記憶體也挺好的，把硬盘叫做硬碟这样子就没人会搞混了</s>就是<strong>物理内存 (physical memory)</strong>，物理内存是由 8 比特的字节组合而成的，每个字节都有一个唯一的地址也就是<strong>物理地址 (physical address)</strong>。对于不支持 64 位架构的处理器，<strong>物理内存空间</strong> <strong>(physical address space)</strong> 范围是从 0 开始到 2<sup>36</sup>-1 (64GB)(段寻址 4 + 寄存器 32)。</p><p>呃，这边有个小小的问题。实际上如果只有 32 位地址的话，最大的寻址空间应该是 2<sup>32</sup> 也就是我们常见认知的 4GB，但是如果启用了<strong>物理地址扩展</strong> **(Physical Address Extension,PAE)** 的话，是可以访问超过 4GB 的物理内存的。</p><p>实际上，任何使用 IA-32 处理器的操作系统或者外部程序都使用处理器的内存管理设备 (memory management facilities) 来访问内存。内存管理设备提供了分段和分页等功能，以提供更高的效率和可靠性。</p><h2 id="ia-32内存模型"><a class="anchor" href="#ia-32内存模型">#</a> IA-32 内存模型</h2><p>运行在 IA-32 处理器上的程序通过内存管理设备访问内存，也就是不直接去访问内存。有几种常见的内存分配模型：</p><h3 id="平面内存模型flat-memory-model"><a class="anchor" href="#平面内存模型flat-memory-model">#</a> 平面内存模型 (flat memory model)</h3><p>平面内存模型中内存是单独一段的连续的地址空间。这个地址空间也被叫做<strong>线性地址空间 (linear address space)</strong>。代码、数据和栈都在这个空间内，这个空间按照字节来寻址，其中的一个地址就是<strong>线性地址 (linear address)</strong>。</p><p><img loading="lazy" data-src="linear-address.jpg" alt=""></p><p><em>草，原来老师也是从这里面截的图……</em></p><h3 id="分段内存模型segmented-memory-model"><a class="anchor" href="#分段内存模型segmented-memory-model">#</a> 分段内存模型 (segmented memory model)</h3><p>在分段内存空间中，一个程序的内存地址被分为了若干段，代码、数据、栈等都分别存储在各自的段内。一个程序使用逻辑地址来编址一个段中的字节数据，这个地址包括了一个段基址和一个相对于基址的偏移。每个段可以有 2<sup>32</sup> 字节的大小。而在处理器内部，所有的段都被映射到处理器的线性地址空间，对于某个内存位置的访问都由处理器内部转换完成，这些过程对程序是透明的。</p><p><img loading="lazy" data-src="segmented-address.jpg" alt=""></p><h3 id="实模式地址模型real-address-mode-memory-model"><a class="anchor" href="#实模式地址模型real-address-mode-memory-model">#</a> 实模式地址模型 (Real-Address mode memory model)</h3><p>这个模式用于 8086 处理器，用来支持运行在 8086 处理器上面的程序。实模式下使用一个特殊的段内存接口，程序的线性地址由一系列 64KB 的段构成。这个模式下线性地址空间的最大大小是 2<sup>20</sup> 字节。</p><p><img loading="lazy" data-src="real-mode-address.jpg" alt=""></p><h3 id="不同运行模式下的内存模型"><a class="anchor" href="#不同运行模式下的内存模型">#</a> 不同运行模式下的内存模型</h3><p>对于保护模式下的 CPU，上面的三种内存模型都是可以被使用的，而其中，实模式地址模型一般是用在虚拟 8086 模式下。具体模型的选取取决于实际运行的操作系统，而对于多任务，不同的任务可以采用不同的地址模型。</p><p>实模式仅仅能够使用实地址模型。</p><p>对于系统管理模式，处理器会使用一个独立的地址空间<strong>系统管理 RAM (system management RAM, SMRAM)</strong>。SMRAM 的编址方式和实模式类似。</p><h2 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h2><h3 id="实模式"><a class="anchor" href="#实模式">#</a> 实模式</h3><p>在实模式下，处理器直接使用 segment selector 来形成地址。处理器将段选择器 segment selector 左移 4 位形成 20bit 的基址，并将其和偏移值相加得到物理地址。如图所示。</p><p><img loading="lazy" data-src="real-mode-mgr.jpg" alt=""></p><p>举个例子，如果 segment selector 数据为 0x1234，偏移为 0x5678，那么实际得到的地址就是 0x12340+0x5678=0x179B8。</p><p>这里有个问题，这种计算可以使得结果超出 20bit 的地址长度，在 8086 处理器中，超出的部分会被截断。但是在实模式下，超出的部分不会被截断，这一部分仍然会被用作物理地址。在 Intel 486 之后的处理器中，实模式下的 A20# 信号用来作为地址 A20 的掩码，来形成 8086 的截断 20bit 地址总线的效果。</p><h3 id="保护模式-2"><a class="anchor" href="#保护模式-2">#</a> 保护模式</h3><p>IA-32 的内存管理设备分为两个部分：分段和分页。分段可以隔离程序的代码、数据和栈，而分页则为按需分页的使用虚拟内存的操作系统提供执行环境。分页功能是可以被关闭的，但是分段不能，没办法关掉分段。</p><p>图就是 IA-32 的分页和分段机制。</p><p><img loading="lazy" data-src="segment-and-page.jpg" alt=""></p><p>分段机制让处理器的线性地址空间划分称了若干个小的地址段，如果处理器上有多个程序在运行，那么每个程序都会被分配到自己的一系列段，同时处理器也会保证不同程序之间的段不会相互影响。分段机制也可以标识不同段的类别（代码、数据、栈等）来保证不同的段上做的是该做的事情。</p><p>这样子，系统中的所有段都分布在处理器的线性地址空间里面，为了去寻找某个段内的一个字节，我们需要一个<strong>逻辑地址</strong> (<strong>logical address</strong>, or <strong>far pointer</strong>)。逻辑地址包括了一个段选择器 segment selector 和一个偏移。段选择器是每个段唯一 (unique) 的标识符，它提供一个描述符表 (descriptor table)，如<strong> GDT (global descriptor table，全局描述符表)</strong> 或者上的偏移，指向了上面的一个<strong>段描述符 (segment descriptor)</strong> 的数据结构。</p><p><img loading="lazy" data-src="logical-to-linear.jpg" alt=""></p><p>每个段都有一个自己的段描述符，包括了段的大小、访问权限和特权等级、类型和段线性基址（在线性地址空间中段第一个字节的地址）。</p><p>一个段的基址加上逻辑地址中的偏移也就构成了段上任意一个字节的地址。由此，我们可以完成段上的寻址，也就是图上左边逻辑地址到线性地址空间的寻址。在没有分页的情况下，线性地址空间是直接映射到物理地址空间的，我们可以直接使用线性地址空间的地址去访问地址总线。</p><p>分页部分课纲里面没有，之后单独拿出来说。</p><h1 id="ia-32-寄存器"><a class="anchor" href="#ia-32-寄存器">#</a> IA-32 寄存器</h1><p>IA-32 指令集下，用于基本的程序执行的寄存器分为四个类型：</p><ul><li>通用寄存器 (general-purpose registers)</li><li>段寄存器 (segment registers)</li><li>程序状态和控制寄存器 (program status and control register, EFLAGS register)</li><li>指令指针寄存器 (instruction pointer register, EIP register)</li></ul><p><img loading="lazy" data-src="regs.jpg" alt=""></p><p>除这些之外，还有用于控制、调试、系统表指针、FPU 等的寄存器。</p><h2 id="通用寄存器"><a class="anchor" href="#通用寄存器">#</a> 通用寄存器</h2><p>通用寄存器包括了 EAX，EBX，ECX，EDX，ESI，EDI，EBP，ESP。它们可以用于逻辑和算数运算、地址运算和作为内存指针。</p><p>但是其中，ESP 寄存器一般是作为栈指针使用的，不该用于其他的用途。</p><p>同时，许多指令是针对特定的寄存器进行操作的。如字符串操作使用的是 ECX、ESI 和 EDI 作为操作数。一些指令假定某个寄存器中就是需要的指针，比如 EBX 常被假定里面存放了 DS 段的内存地址指针。</p><ul><li>EAX：累加器的操作数和结果</li><li>EBX：指向 DS 段中数据的指针</li><li>ECX：字符串计数器和循环的计数器</li><li>EDX：I/O 指针</li><li>ESI：指向 DS 寄存器标识的段中数据的指针；字符串操作的源指针</li><li>EDI：指向 ES 寄存器标识的段中数据或者目的地址的指针；字符串操作的目的指针</li><li>ESP：栈顶指针</li><li>EBP：栈基指针</li></ul><p>通用寄存器实际上的可以分割的，如图所示：</p><p><img loading="lazy" data-src="gen-regs.jpg" alt=""></p><p>通过对寄存器的分割，可以实现更加高效的利用。</p><blockquote><p>其实从之前微原实验手搓 8086 汇编的经历来看，真的是寄存器之间和炒菜一样来回倒腾，一个寄存器当两个用，放不下了还要往栈里面硬塞，对比来看 MIPS 优雅多了（</p></blockquote><h2 id="段寄存器"><a class="anchor" href="#段寄存器">#</a> 段寄存器</h2><p>段寄存器存放的就是 16bit 的段选择器。它们的使用方式取决于操作系统的内存模型。</p><p>如果操作系统使用的是平面内存模型，那么段寄存器重叠指向线性地址空间的 0 的位置。</p><p><img loading="lazy" data-src="flat-seg-reg.jpg" alt=""></p><p>不过这种情况通常来说，能把内存分为两个段，<strong>代码段</strong>和<strong>数据、栈段</strong>。CS 段寄存器指向代码段，剩下的所有段寄存器指向数据和堆栈段。</p><p>而当使用了分段模型，每一个段寄存器都包含了不同的段选择器，以此标识了线性地址空间中不同的段的地址。一个程序可以同时访问线性地址空间中的 6 个段，但是如果要访问不在段寄存器内的段，则要提前装载对应的寄存器。</p><p>CS 寄存器包含了<strong>代码段 (code segment)</strong> 的段选择器。代码段中存储了程序的指令，处理器使用一个包含了 CS 中的段选择器和 EIP 寄存器的值的逻辑地址去获取将要执行的指令。</p><p>DS、ES、FS、GS 四个寄存器指向四个<strong>数据段 (data segment)</strong>。</p><p>SS 寄存器是包含了<strong>栈段 (stack segment)</strong> 的段选择器。</p><h2 id="eflags寄存器"><a class="anchor" href="#eflags寄存器">#</a> EFLAGS 寄存器</h2><p>EFLAGS 寄存器有 32bit，包含了状态、控制和一系列系统信息的标志。如图所示：</p><p><img loading="lazy" data-src="eflags.jpg" alt=""></p><p>下面是一些标志位的详细作用：</p><p>状态标志：</p><ul><li>CF: 进位标志。如果运算进位或者借位，那么设置这个标识符。这个标志位可以提示无符号整数溢出（set as 1），在多精度运算中也有使用。</li><li>PF: 奇偶标志。如果运算结果是偶数，置为 1，否则置 0。（置为 LSB 取反）</li><li>AF: 辅助进位标志。用于 BCD 计算。</li><li>ZF: 零标志。如果结果为 0 则置 1，否则置 0。</li><li>SF: 符号标志。如果结果为正数，置为 0，否则置为 1。（置为 MSB）</li><li>OF: 溢出标志。向上或向下溢出则置为 1，否则为 0。用于有符号整数运算。</li></ul><p>DF 标志：用于字符串操作，设置为 1 即从高地址向低地址，反之亦然。</p><p>系统标志位和 IOPL 域：</p><ul><li>TF: 陷阱标志。在单步调试下设置为 1，否则为 0。</li><li>IF: 中断使能。在设置为 1 时会对可屏蔽中断响应。</li><li>IOPL: I/O 特权等级域。标识当前运行的程序的 I/O 特权等级，这个值应该大于等于当前程序的<strong> CPL (current privilege level)</strong>。</li><li>NT: 嵌套任务。用于中断的嵌套和任务调用嵌套。</li><li>RF: 恢复标志。控制处理器对调试终端的响应。</li><li>VM: 虚拟 8086 模式标志。设置之后启用虚拟 8086 模式。</li><li>AC: 对齐检查或者访问控制。</li><li>VIF: 虚拟中断。</li><li>VIP: 虚拟中断挂起。</li><li>ID: 标识符位。用于 CPUID 指令。</li></ul><h2 id="eip寄存器"><a class="anchor" href="#eip寄存器">#</a> EIP 寄存器</h2><p>EIP 寄存器包含了当前代码段下一条需要执行的指令的偏移。通过一些流程控制语句、中断和异常语句，可以控制 EIP 的值。但是软件不能够直接获取到自己的 EIP 的值。</p><h1 id="基本的数据类型"><a class="anchor" href="#基本的数据类型">#</a> 基本的数据类型</h1><p>IA-32 基本的数据类型分为字节 (byte, 8 bit)、字 (word, 16 bit)、双字 (dword, 32 bit)、四字 (qword, 64 bit)、双四字 (double qword, 128 bit) 等：</p><p><img loading="lazy" data-src="base-data.jpg" alt=""></p><p>在内存中，数据以这样的小端序存储：</p><p><img loading="lazy" data-src="example-word.jpg" alt=""></p><p>在实际使用中，程序为了提高性能，一般采用对齐的方式存储数据。</p><h2 id="数字类型"><a class="anchor" href="#数字类型">#</a> 数字类型</h2><p>一些指令支持特殊的数据类型，包括整数（有符号的和无符号的）和浮点数（32 bit 单精度、64 bit 双精度），它们的结构如图所示：</p><p><img loading="lazy" data-src="num.jpg" alt=""></p><p>浮点数实际上是遵循 IEEE 754 标准，这里不加赘述，有需要以后再写。</p><h2 id="指针类型"><a class="anchor" href="#指针类型">#</a> 指针类型</h2><p>指针是内存中的地址。在非 64 位的模式中，指针分为近指针 (near pointer) 和远指针 (far pointer).</p><p>近指针是 32bit 长度的段上偏移（有效地址），一般在平面内存模型或者已经明确了某一个段的情况下使用。而远指针是一个逻辑地址，包含了一个 16 bit 的段选择器，用于精确地访问某个地址。</p><p><img loading="lazy" data-src="pointer.jpg" alt=""></p><p>除了这些之外，还包括比特串、字符串等其他的类型。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>写得够呛，一边看幻灯片一边读 Intel 的手册，感觉还是 Intel 的手册好懂一些，就是太长了……</p><p>希望别坑了</p><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p>[1] 老师的课件。</p><p>[2] 《软件逆向工程 —— 原理与实践》，孙聪 等著，西安电子科技大学出版社。</p><p>[3] 英特尔 ® 64 位和 IA-32 架构开发人员手册：卷 1。</p><p>[4] 英特尔 ® 64 位和 IA-32 架构开发人员手册：卷 3。</p><div class="tags"><a href="/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i>逆向工程</a><a href="/tags/x86/" rel="tag"><i class="ic i-tag"></i>x86</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2022/01/20/re-review1/">加载中...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-09-10 14:48:49" itemprop="dateModified" datetime="2025-09-10T14:48:49+08:00">2025-09-10</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>神隐陌路/symlPigeon<i class="ic i-at"><em>@</em></i>symlpigeon's little gensokyo</li><li class="link"><strong>本文链接：</strong><a href="http://symlpigeon.github.io/2022/01/20/re-review1/" title="IA32内存、寄存器、数据">http://symlpigeon.github.io/2022/01/20/re-review1/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/01/07/some-attack-on-rsa-I/" rel="prev" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18bsrq063j21hd0u0jyn.jpg" title="一些针对RSA的攻击（I）"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>整数环上的密码学</span><h3>一些针对RSA的攻击（I）</h3></a></div><div class="item right"><a href="/2022/02/07/mpc-1/" rel="next" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18c6r31tcj216d0u0qd2.jpg" title="安全多方计算——定义、原语"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>安全计算</span><h3>安全多方计算——定义、原语</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#x86%E5%92%8Cx64ia-32"><span class="toc-number">1.</span> <span class="toc-text">x86 和 x64，IA-32</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">保护模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">实模式 &#x2F; 实地址模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">系统管理模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%BA%A7%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">权限级别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ia-32-%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">IA-32 内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ia-32%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">IA-32 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bflat-memory-model"><span class="toc-number">2.1.1.</span> <span class="toc-text">平面内存模型 (flat memory model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bsegmented-memory-model"><span class="toc-number">2.1.2.</span> <span class="toc-text">分段内存模型 (segmented memory model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%9E%8Breal-address-mode-memory-model"><span class="toc-number">2.1.3.</span> <span class="toc-text">实模式地址模型 (Real-Address mode memory model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">不同运行模式下的内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">实模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">保护模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ia-32-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">IA-32 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eflags%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">EFLAGS 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eip%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">EIP 寄存器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基本的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">数字类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">指针类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/01/20/re-review1/" rel="bookmark" title="IA32内存、寄存器、数据">IA32内存、寄存器、数据</a></li><li><a href="/2022/02/10/re-review2/" rel="bookmark" title="ELF格式学习">ELF格式学习</a></li><li><a href="/2022/02/15/re-call/" rel="bookmark" title="关于x86调用惯例是啥这件事">关于x86调用惯例是啥这件事</a></li><li><a href="/2022/03/22/program-start/" rel="bookmark" title="关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果">关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="神隐陌路/symlPigeon" src="/assets/avatar.png"><p class="name" itemprop="name">神隐陌路/symlPigeon</p><div class="description" itemprop="description">夢違え、幻の朝靄の世界の記憶を</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">51</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">45</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/symlpigeon" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;symlpigeon"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=540913144" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;540913144"><i class="ic i-cloud-music"></i></a><a href="mailto:2163953074@qq.com" class="item email" title="mailto:2163953074@qq.com"><i class="ic i-envelope"></i></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/users/20091462/symlpigeon" class="item stackoverflow" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;20091462&#x2F;symlpigeon"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return!1"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/02/07/mpc-1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/01/07/some-attack-on-rsa-I/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2021 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">神隐陌路/symlPigeon @ Another Gensokyo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">421k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:23</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={ispost:!0,path:"2022/01/20/re-review1/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},nocopy:"false",nocopy:!1,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',copy_tex:!0,katex:!0,mermaid:!1,audio:void 0,fancybox:!0,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[e=>e.includes("#"),e=>new RegExp(LOCAL.path+"$").test(e),[]]}</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->