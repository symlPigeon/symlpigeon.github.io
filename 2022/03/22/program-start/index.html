<!-- build time: Wed Sep 10 2025 16:38:05 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="google-site-verification" content="ZTJV7LmnjnAU0rDyvzCr7TRRA440DNEQPOSHt9OiYLE"><link rel="alternate" href="/rss.xml" title="symlpigeon's little gensokyo" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="symlpigeon's little gensokyo" type="application/atom+xml"><link rel="alternate" type="application/json" title="symlpigeon's little gensokyo" href="http://symlpigeon.github.io/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-4ZVORXXI.js"><link rel="modulepreload" href="/js/chunk-QTIRA53W.js"><link rel="modulepreload" href="/js/copy-tex-SCXHUQKS.js"><link rel="modulepreload" href="/js/post-XSNAZ6TV.js"><link rel="modulepreload" href="/js/quicklink-P2UCCMRY.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="/assets/index-bg.jpg" as="image" fetchpriority="high"><meta name="keywords" content="ELF,"><meta name="description" content="到现在才发现连一个程序怎么启动都不知道，所以说想好好学一下这个问题。主要还是关于_start, _init这些奇怪的函数。"><link rel="canonical" href="http://symlpigeon.github.io/2022/03/22/program-start/"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js"></script><style type="text/css">#categories-chart,#categories-radar,#posts-calendar,#posts-chart,#tags-chart{width:100%;height:300px;margin:.5rem auto;padding:.5rem;overflow-x:auto}</style><title>关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果</h1><div class="meta"><span class="item" title="创建时间：2022-03-22 16:46:07"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2022-03-22T16:46:07+08:00">2022-03-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>13k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Another Gensokyo</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="/assets/index-bg.jpg" loading="eager" decoding="async" fetchpriority="high" alt="symlpigeon's little gensokyo"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="item" rel="index" title="分类于二进制"><span itemprop="name">二进制<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于二进制基础"><span itemprop="name">二进制基础<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://symlpigeon.github.io/2022/03/22/program-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.png"><meta itemprop="name" content="神隐陌路/symlPigeon"><meta itemprop="description" content="神隐陌路的个人小站, 夢違え、幻の朝靄の世界の記憶を"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="symlpigeon's little gensokyo"></span><div class="body md" itemprop="articleBody"><p>之前偶尔写一些逆向的时候总会看到 IDA 反汇编出来的函数列表里面有 <code>_start</code> 这样的奇奇怪怪的函数，在调试的时候 <code>main</code> 函数 <code>return</code> 之后也会到一些奇奇怪怪的地方去。感觉是应该去把这些东西给理一下了。</p><h1 id="程序的启动和execve"><a class="anchor" href="#程序的启动和execve">#</a> 程序的启动和 <code>execve</code></h1><p>我们在 shell 中执行一个程序的时候，Linux 内核会去装载这个程序并且去执行。</p><p>按照以前所学的 shell 的实现，当在终端中输入了一条命令之后，shell 会进行 <code>fork()</code> 调用创建一个新的进程，并在新的进程中执行这条命令。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">run_command</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> command<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> args_cnt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//background 指定命令是否在后台运行</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> background <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span>args_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"&amp;"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 以 & amp; 参数结尾的命令，在后台中运行</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        args<span class="token punctuation">[</span>args_cnt <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        background <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">run_inner_command</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 排除掉 shell 的内置指令</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">//shell 会 fork 一个新的进程</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token comment">//fork 失败，报错</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unable to fork child process!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 既然 pid 是 0，说明是子进程</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token comment">// 调用 execvp 去执行命令，这个 execvp 下面再说</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">execvp</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> args<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    <span class="token comment">// 返回值 - 1 说明执行失败</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error when executing command %s\n"</span><span class="token punctuation">,</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token comment">// 结束子进程的执行</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token comment">//pid 不是 0，是父进程</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>background<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                    <span class="token comment">// 如果命令不是后台执行那么就得等待子进程结束了</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                    <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>                    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>前面提到了 <code>execvp(const char* file, char* const argv[])</code> ，这个函数定义在 <code>unistd.h</code> 中。这个头文件中还定义了其他的一系列函数：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">execle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">execvpe</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>应该说这些函数实际上都是通过调用 <code>execve</code> 来实现的。这些函数定义在 glibc 中，通过一个系统调用来实现。</p><p>glibc 中的 execve 产生的系统调用会被 Linux 内核接收并处理，Linux 内核会读取对应的文件并装载入内存进行执行。内核中对这个过程的实现包括了一系列的函数，在这里就不多说了。</p><h1 id="入口点和_start"><a class="anchor" href="#入口点和_start">#</a> 入口点和 <code>_start</code></h1><p>我们写一个简单的程序。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这仅仅是一个空的函数体，只能勉强称之为 “程序”。编译之后，通过 <code>readelf</code> 读取文件头信息：</p><pre><code>ELF 头：
  Magic：  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF32
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              DYN (Position-Independent Executable file)
  系统架构:                          Intel 80386
  版本:                              0x1
  入口点地址：              0x1050
  程序头起点：              52 (bytes into file)
  Start of section headers:          14180 (bytes into file)
  标志：             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         12
  Size of section headers:           40 (bytes)
  Number of section headers:         36
  Section header string table index: 35

</code></pre><p>可以看到程序的入口点是 <code>0x1050</code> 。我们通过 objdump 反汇编查看对应的入口点：</p><pre><code class="language-x86asm">00001050 &lt;_start&gt;:
    1050:       f3 0f 1e fb             endbr32 
    1054:       31 ed                   xor    ebp,ebp
    1056:       5e                      pop    esi
    1057:       89 e1                   mov    ecx,esp
    1059:       83 e4 f0                and    esp,0xfffffff0
    105c:       50                      push   eax
    105d:       54                      push   esp
    105e:       52                      push   edx
    105f:       e8 18 00 00 00          call   107c &lt;_start+0x2c&gt;
    1064:       81 c3 9c 2f 00 00       add    ebx,0x2f9c
    106a:       6a 00                   push   0x0
    106c:       6a 00                   push   0x0
    106e:       51                      push   ecx
    106f:       56                      push   esi
    1070:       ff b3 f8 ff ff ff       push   DWORD PTR [ebx-0x8]
    1076:       e8 c5 ff ff ff          call   1040 &lt;__libc_start_main@plt&gt;
    107b:       f4                      hlt    
    107c:       8b 1c 24                mov    ebx,DWORD PTR [esp]
    107f:       c3                      ret    
</code></pre><p>和常识并不相符 —— 程序的入口点实际上对应的是这个 <code>_start</code> 函数，而不是 <code>main</code> 函数。</p><p>如果用 GDB 进行调试，实际上程序在最开始会从 <code>_start</code> 跳转进入 <code>_dl_start</code> 函数进行操作，这个函数是 glibc 中的一个函数，Linux 系统中在执行 <code>execve</code> （实际上是 <code>do_execveat_common</code> ）时调用它，主要是用来进行动态链接。在程序执行结束之后，也有一个类似的函数用来解除动态链接。</p><p>最开始的 <code>endbr32</code> （或者 <code>endbr64</code> ）指令的作用是用作跳转的目的地址，跳转的目的地址位置上的指令是 <code>endbr32</code> 说明这是这个跳转有效，这个指令此外并没有作用。</p><p>首先这里执行了 <code>xor ebp, ebp</code> ，将 <code>ebp</code> 的值置为 0。接下来， <code>pop esi</code> 指令将栈顶的数据弹出到 <code>esi</code> 中。</p><p><img loading="lazy" data-src="start-dbg1.jpg" alt=""></p><p>图片是在执行 <code>pop esi</code> 的上一步操作，此时 <code>esi</code> 的值是之前 <code>dl_start</code> 调用留下的，指向栈上的一个位置。而 <code>EBP</code> 的值已经被设置为了 0x0。</p><p>在执行完 <code>pop esi</code> 之后，我们观察程序的栈：</p><p><img loading="lazy" data-src="start-dbg1.5.jpg" alt=""></p><p>先前在栈顶的位置上是 <code>argc</code> （0x1），被弹出之后，现在剩下 <code>argv</code> 和 <code>envp</code> 。</p><p><code>mov ecx, esp</code> 将 <code>esp</code> 的值放入 <code>ecx</code> 中，也就是将 <code>ecx</code> 指向目前栈顶的位置，这个位置存放的实际上就是 <code>argv</code> 。</p><p><img loading="lazy" data-src="start-dbg2.jpg" alt=""></p><p>接下来的操作 <code>and esp, 0xfffffff0</code> 将 <code>esp</code> 的最低 4 位置为了 0。这一步显然会让栈顶向上移动，但是移动的距离是不固定的，取决于执行这条命令之前栈顶的位置。这样操作的目的在于将栈顶和 4 字节对齐。</p><p>接下来的一段代码是这些：</p><pre><code class="language-x86asm">push    eax
push    esp
push    edx
call    _start+0x2c
</code></pre><p>在执行 <code>call _start+0x2c</code> 之前，程序的寄存器和栈分别是：</p><pre><code> EAX  0xf7ffda20 —▸ 0x56555000 ◂— 0x464c457f
 EBX  0xf7ffcfd4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x37f2c
 ECX  0xffffd034 —▸ 0xffffd210 ◂— '/home/syml/Temp/test'
 EDX  0xf7fcaa30 (_dl_fini) ◂— endbr32 
 EDI  0x56556050 (_start) ◂— endbr32 
 ESI  0x1
 EBP  0x0
*ESP  0xffffd024 —▸ 0xf7fcaa30 (_dl_fini) ◂— endbr32 
*EIP  0x5655605f (_start+15) ◂— call   0x5655607c
----------------------------------------------------------------
00:0000│ esp 0xffffd024 —▸ 0xf7fcaa30 (_dl_fini) ◂— endbr32 
01:0004│     0xffffd028 —▸ 0xffffd02c —▸ 0xf7ffda20 —▸ 0x56555000 ◂— 0x464c457f
02:0008│     0xffffd02c —▸ 0xf7ffda20 —▸ 0x56555000 ◂— 0x464c457f
03:000c│     0xffffd030 ◂— 0x1
04:0010│ ecx 0xffffd034 —▸ 0xffffd210 ◂— '/home/syml/Temp/test'
05:0014│     0xffffd038 ◂— 0x0
06:0018│     0xffffd03c —▸ 0xffffd225 ◂— 'SHELL_SESSION_ID=7d181dfe24dd4f97af595a6b18695b24'
07:001c│     0xffffd040 —▸ 0xffffd257 ◂— 'DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus'
</code></pre><p>这一段代码接下来跳转到下面的部分：</p><pre><code class="language-x86asm">mov     ebx, dword ptr [esp]
ret
</code></pre><p>第一条指令将栈顶的数据放入 <code>ebx</code> 中。经过上一步的 <code>call</code> 指令操作，栈顶现在的值为 <code>call</code> 的指令返回地址，也就是 <code>call</code> 的下一条指令所在的地方。</p><p>接下来执行 <code>ret</code> ，程序返回 <code>esp</code> 所指位置的值对应的地址，也就是 <code>call</code> 下一条指令的位置。（将栈顶的元素弹出到 <code>eip</code> ）</p><p>下面的指令是 <code>add ebx, 0x2148</code> 。</p><p>在执行之后，各个寄存器的值：</p><p><img loading="lazy" data-src="start-dbg3.jpg" alt=""></p><p>在这个时候， <code>ebx</code> 指向了 <code>_GLOBAL_OFFSET_TABLE_</code> 。</p><p>接下来的指令序列分别是：</p><pre><code class="language-x86asm">push    0
push    0
push    ecx ; argc
push    esi
push    dword ptr [ebx - 8] ; 
call    __libc_start_main@plt
</code></pre><p>执行完前面的 <code>push</code> 指令序列之后，栈上的情况是：</p><p><img loading="lazy" data-src="start-dbg4.jpg" alt=""></p><p>这里 <code>dword ptr [ebx - 8]</code> 指针实际对应的位置就是 <code>main</code> 函数的入口点。</p><p>查看 <code>__libc_start_main</code> 的定义：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">__libc_start_main</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>main<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> argc<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token operator">*</span> ubp_av<span class="token punctuation">,</span> <span class="token comment">// argv</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>init<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fini<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>rtld_fini<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span> stack_end<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以将参数和栈上的数据进行对应：</p><table><thead><tr><th>参数</th><th>作用</th><th>栈上位置</th><th>值</th></tr></thead><tbody><tr><td><code>int (*main)(int, char**, char**)</code></td><td>程序的 <code>main</code> 函数</td><td><code>ESP</code></td><td><code>0x5655617d (main)</code></td></tr><tr><td><code>int argc</code></td><td>参数 <code>argv</code> 的个数</td><td><code>ESP+4</code></td><td><code>0x1</code></td></tr><tr><td><code>char** ubp_av</code></td><td>参数 <code>argv</code></td><td><code>ESP+8</code></td><td><code>0xffffd034-&gt;0xffffd210</code></td></tr><tr><td><code>void (*init)(void)</code></td><td><code>_libc_csu_init</code> 函数</td><td><code>ESP+C</code></td><td><code>NULL(0)</code></td></tr><tr><td><code>void (*fini)(void)</code></td><td><code>_libc_csu_fini</code> 函数</td><td><code>ESP+10</code></td><td><code>NULL(0)</code></td></tr><tr><td><code>void (*rtld_fini)(void)</code></td><td>动态链接器的析构函数</td><td><code>ESP+14</code></td><td><code>0xf7fcaa30(_dl_fini)</code></td></tr><tr><td><code>void (*stack_end)</code></td><td>栈指针</td><td><code>ESP+18</code></td><td>原 <code>ESP</code> 值</td></tr></tbody></table><p>下面执行调用，程序进入 <code>__libc_start_main</code> 中。注意这里跳转到的实际上是 <code>plt</code> 表中对应的表项，这是一个到内存中的索引。实际上还需要另外一次跳转。</p><h1 id="__libc_start_main"><a class="anchor" href="#__libc_start_main">#</a> <code>__libc_start_main</code></h1><blockquote><p>当程序进入了 glibc 的代码部分之后，常规人类的思维就逐渐难以跟上了。</p></blockquote><p>函数 <code>__libc_start_main</code> 实际在 <code>glibc</code> 下的源码 <code>csu/libc-start.c</code> 中，对应了函数：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>STATIC <span class="token keyword">int</span> <span class="token function">LIBC_START_MAIN</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>main<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>MAIN_AUXVEC_DECL<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                           <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LIBC_START_MAIN_AUXVEC_ARG</span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>                           <span class="token function">ElfW</span><span class="token punctuation">(</span><span class="token class-name">auxv_t</span><span class="token punctuation">)</span> <span class="token operator">*</span> auxvec<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>                           <span class="token function">__typeof</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span> init<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fini<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                           <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>rtld_fini<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>stack_end<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>noreturn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的具体内容暂且不说，里面做了包括了这样几件事情：</p><p>重定位，PIE</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">_dl_relocate_static_pie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>canary</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* Set up the pointer guard value.  */</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token class-name">uintptr_t</span> pointer_chk_guard <span class="token operator">=</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token function">_dl_setup_pointer_guard</span><span class="token punctuation">(</span>_dl_random<span class="token punctuation">,</span> stack_chk_guard<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>调用了 <code>init</code> ：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* Call the initializer of the program, if any.  */</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">SHARED</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token function">GLRO</span><span class="token punctuation">(</span>dl_debug_mask<span class="token punctuation">)</span> <span class="token operator">&amp;</span> DL_DEBUG_IMPCALLS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">GLRO</span><span class="token punctuation">(</span>dl_debug_printf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"\ninitialize program: %s\n\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">(</span><span class="token operator">*</span>init<span class="token punctuation">)</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> __environ MAIN_AUXVEC_PARAM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>调用主函数，同时将参数传递进去：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>ev <span class="token operator">=</span> <span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>argc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">/* Nothing fancy, just call the function.  */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  result <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> __environ MAIN_AUXVEC_PARAM<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>处理最终的结果：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">exit</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h1 id="__libc_csu_init"><a class="anchor" href="#__libc_csu_init">#</a> <code>__libc_csu_init</code></h1><p>在许多情况下， <code>init</code> 指向的是 glibc 的 <code>__libc_csu_init</code> 函数，这个函数定义在了 <code>csu/elf-init.c</code> 中。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">__libc_csu_init</span> <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">/* For dynamically linked executables the preinit array is executed by</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     the dynamic linker (before initializing any shared object).  */</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LIBC_NONSHARED</span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token comment">/* For static executables, preinit happens right before init.  */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">const</span> <span class="token class-name">size_t</span> size <span class="token operator">=</span> __preinit_array_end <span class="token operator">-</span> __preinit_array_start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token class-name">size_t</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token punctuation">(</span><span class="token operator">*</span>__preinit_array_start <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NO_INITFINI</span></span></pre></td></tr><tr><td data-num="18"></td><td><pre>  <span class="token function">_init</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token keyword">const</span> <span class="token class-name">size_t</span> size <span class="token operator">=</span> __init_array_end <span class="token operator">-</span> __init_array_start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token punctuation">(</span><span class="token operator">*</span>__init_array_start <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>去除掉其中暂时用不着的宏定义部分，这个函数做的是这些：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> <span class="token class-name">size_t</span> size <span class="token operator">=</span> __init_array_end <span class="token operator">-</span> __init_array_start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token punctuation">(</span><span class="token operator">*</span>__init_array_start <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数实际上是整个程序的 “构造函数”。首先它调用了函数 <code>_init()</code> 。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* These function symbols are provided for the .init/.fini section entry</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   points automagically by the linker.  */</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">_init</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">_fini</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="_init"><a class="anchor" href="#_init">#</a> <code>_init</code></h2><p>这边并没有给出定义，只有一个简单的声明。我们对程序进行反汇编来看看 <code>_init()</code> 到底做了什么。</p><pre><code class="language-x86asm">00001000 &lt;_init&gt;:
    1000:       f3 0f 1e fb             endbr32 
    1004:       53                      push   ebx
    1005:       83 ec 08                sub    esp,0x8
    1008:       e8 73 00 00 00          call   1080 &lt;__x86.get_pc_thunk.bx&gt;
    100d:       81 c3 9f 21 00 00       add    ebx,0x219f
    1013:       8b 83 f4 ff ff ff       mov    eax,DWORD PTR [ebx-0xc]
    1019:       85 c0                   test   eax,eax
    101b:       74 02                   je     101f &lt;_init+0x1f&gt;
    101d:       ff d0                   call   eax
    101f:       83 c4 08                add    esp,0x8
    1022:       5b                      pop    ebx
    1023:       c3                      ret    
</code></pre><p><code>get_pc_thunk</code> 这个函数是用来处理 <code>Global Offset Table</code> （GOT 表），这和<em>地址无关代码</em>有关。这个函数可以获取当前指令的位置，这样加上一个偏移就可以访问一些资源。</p><pre><code class="language-x86asm">00001080 &lt;__x86.get_pc_thunk.bx&gt;:
    1080:       8b 1c 24                mov    ebx,DWORD PTR [esp]
    1083:       c3                      ret    
    1084:       66 90                   xchg   ax,ax ; 在x86中对应nop
    1086:       66 90                   xchg   ax,ax
    1088:       66 90                   xchg   ax,ax
    108a:       66 90                   xchg   ax,ax
    108c:       66 90                   xchg   ax,ax
    108e:       66 90                   xchg   ax,ax
</code></pre><p>这里有趣的是，在执行调用语句 <code>call &lt;__x86.get_pc_thunk.bx&gt;</code> 的时候，栈顶被压入了下一条指令也就是 <code>add ebx,0x219f</code> 的地址。而这个时候 <code>mov ebx,DWORD PTR [esp]</code> 实际上放入 <code>ebx</code> 的也就是这条指令的地址。</p><p>接下来执行的 <code>add</code> 语句中 <code>0x219f</code> 就是当前代码相较于位置无关代码的偏移。接下来就是将对应地址中的数据读取到寄存器 <code>eax</code> 中，如果对应的地址有效那么便去执行其中的代码 ( <code>gmon_start</code> / <code>frame_dummy</code> 之类的？)，否则继续也就是结束这个函数的执行。</p><blockquote><p>我看有些教程里面提到了有函数 <code>_do_global_ctors_aux</code> ，但是我没有在这里找到从 <code>_init</code> 开始的调用。头疼……</p></blockquote><h2 id="_do_global_ctors_aux"><a class="anchor" href="#_do_global_ctors_aux">#</a> <code>_do_global_ctors_aux</code></h2><p>这个函数理论上使用来执行构造函数的，也就是 “存放了全局 C++ 对象的构造函数”。</p><p>不过麻烦的是程序编译了之后好像没有这个东西……</p><p>要是啥时候知道了再补上……</p><p>在执行了上面的部分之后（？）， <code>_init</code> 函数也就到了最后结尾，接下来程序返回到 <code>__libc_start_main</code> 中。</p><h1 id="回到__libc_csu_init"><a class="anchor" href="#回到__libc_csu_init">#</a> 回到 <code>__libc_csu_init</code></h1><p>接下来，我们执行到了这个代码段：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token class-name">size_t</span> size <span class="token operator">=</span> __init_array_end <span class="token operator">-</span> __init_array_start<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token punctuation">(</span><span class="token operator">*</span>__init_array_start <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这一段也就是在执行一系列的初始化函数：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// test init</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token string">".init_array"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>init<span class="token punctuation">)</span> <span class="token operator">*</span>__init <span class="token operator">=</span> init<span class="token punctuation">;</span></pre></td></tr></table></figure><p>程序执行的结果也就是这样的：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># syml @ SYMLArch in ~/Temp 0 [18:57:21]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>$ ./test </pre></td></tr><tr><td data-num="3"></td><td><pre>init</pre></td></tr><tr><td data-num="4"></td><td><pre>main</pre></td></tr></table></figure><p>在执行结束这一系列的初始化函数之后， <code>__libc_csu_init</code> 函数结束。接下来程序返回到 <code>__libc_start_main</code> 中，并接着进入 <code>main</code> 函数，在执行完成之后，结果会返回给 <code>exit</code> 函数进行处理。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>最后那这张网上的图来说明一下整个流程，一个程序运行的流程也就是把这棵树先序遍历了一下：</p><p><img loading="lazy" data-src="callgraph.png" alt=""></p><p>总的来看整个流程至少是梳理了一遍…… 但是说实话不少地方还是有点痛苦的，比如说 glibc 的源码实在是太晦涩了，包括部分函数实际上是自动生成的，并没有对应的源码能够查阅。</p><p>这一篇写下来填了一些之前留下的坑，又留了更多的坑……</p><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p>[1] 程序员的自我修养 —— 链接、装载与库</p><p>[2] <a target="_blank" rel="noopener" href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a></p><p>[3] 深入理解 Linux 内核</p><p>[4] glibc 源码</p><p>[5] Linux 源码</p><div class="tags"><a href="/tags/ELF/" rel="tag"><i class="ic i-tag"></i>ELF</a><a href="/tags/Linux/" rel="tag"><i class="ic i-tag"></i>Linux</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2022/03/22/program-start/">加载中...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-09-10 14:48:49" itemprop="dateModified" datetime="2025-09-10T14:48:49+08:00">2025-09-10</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>神隐陌路/symlPigeon<i class="ic i-at"><em>@</em></i>symlpigeon's little gensokyo</li><li class="link"><strong>本文链接：</strong><a href="http://symlpigeon.github.io/2022/03/22/program-start/" title="关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果">http://symlpigeon.github.io/2022/03/22/program-start/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/03/16/wiener-attack/" rel="prev" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18cfhi3lrj215o0sudo1.jpg" title="Wiener&#39;s Attack"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>整数环上的密码学</span><h3>Wiener's Attack</h3></a></div><div class="item right"><a href="/2022/03/23/mpc-gmw/" rel="next" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18c6o49w9j216g0u0461.jpg" title="多方安全计算——GMW协议"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>安全计算</span><h3>多方安全计算——GMW协议</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8Cexecve"><span class="toc-number">1.</span> <span class="toc-text">程序的启动和 execve</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%E7%82%B9%E5%92%8C_start"><span class="toc-number">2.</span> <span class="toc-text">入口点和 _start</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#__libc_start_main"><span class="toc-number">3.</span> <span class="toc-text">__libc_start_main</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#__libc_csu_init"><span class="toc-number">4.</span> <span class="toc-text">__libc_csu_init</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#_init"><span class="toc-number">4.1.</span> <span class="toc-text">_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#_do_global_ctors_aux"><span class="toc-number">4.2.</span> <span class="toc-text">_do_global_ctors_aux</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0__libc_csu_init"><span class="toc-number">5.</span> <span class="toc-text">回到 __libc_csu_init</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/01/20/re-review1/" rel="bookmark" title="IA32内存、寄存器、数据">IA32内存、寄存器、数据</a></li><li><a href="/2022/02/10/re-review2/" rel="bookmark" title="ELF格式学习">ELF格式学习</a></li><li><a href="/2022/02/15/re-call/" rel="bookmark" title="关于x86调用惯例是啥这件事">关于x86调用惯例是啥这件事</a></li><li class="active"><a href="/2022/03/22/program-start/" rel="bookmark" title="关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果">关于一个ELF程序是怎么启动的这件事以及尝试分析然后大失败的结果</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="神隐陌路/symlPigeon" src="/assets/avatar.png"><p class="name" itemprop="name">神隐陌路/symlPigeon</p><div class="description" itemprop="description">夢違え、幻の朝靄の世界の記憶を</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">51</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">45</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/symlpigeon" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;symlpigeon"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=540913144" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;540913144"><i class="ic i-cloud-music"></i></a><a href="mailto:2163953074@qq.com" class="item email" title="mailto:2163953074@qq.com"><i class="ic i-envelope"></i></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/users/20091462/symlpigeon" class="item stackoverflow" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;20091462&#x2F;symlpigeon"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return!1"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/03/23/mpc-gmw/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/03/16/wiener-attack/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2021 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">神隐陌路/symlPigeon @ Another Gensokyo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">421k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:23</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={ispost:!0,path:"2022/03/22/program-start/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},nocopy:"false",nocopy:!1,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',copy_tex:!0,katex:!0,mermaid:!1,audio:void 0,fancybox:!0,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[e=>e.includes("#"),e=>new RegExp(LOCAL.path+"$").test(e),[]]}</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->